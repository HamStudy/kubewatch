
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ui: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/HamStudy/kubewatch/internal/ui/app.go (29.3%)</option>
				
				<option value="file1">github.com/HamStudy/kubewatch/internal/ui/modes.go (66.5%)</option>
				
				<option value="file2">github.com/HamStudy/kubewatch/internal/ui/test_helpers.go (17.1%)</option>
				
				<option value="file3">github.com/HamStudy/kubewatch/internal/ui/views/confirm_view.go (0.0%)</option>
				
				<option value="file4">github.com/HamStudy/kubewatch/internal/ui/views/context_view.go (0.0%)</option>
				
				<option value="file5">github.com/HamStudy/kubewatch/internal/ui/views/data_view.go (0.0%)</option>
				
				<option value="file6">github.com/HamStudy/kubewatch/internal/ui/views/describe_view.go (0.0%)</option>
				
				<option value="file7">github.com/HamStudy/kubewatch/internal/ui/views/help_view.go (0.0%)</option>
				
				<option value="file8">github.com/HamStudy/kubewatch/internal/ui/views/log_view.go (23.1%)</option>
				
				<option value="file9">github.com/HamStudy/kubewatch/internal/ui/views/namespace_view.go (0.0%)</option>
				
				<option value="file10">github.com/HamStudy/kubewatch/internal/ui/views/resource_view.go (21.0%)</option>
				
				<option value="file11">github.com/HamStudy/kubewatch/internal/ui/views/test_helpers.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ui

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/HamStudy/kubewatch/internal/core"
        "github.com/HamStudy/kubewatch/internal/k8s"
        "github.com/HamStudy/kubewatch/internal/ui/views"
        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "k8s.io/apimachinery/pkg/watch"
)

// KeyMap defines the key bindings
type KeyMap struct {
        Up            key.Binding
        Down          key.Binding
        Left          key.Binding
        Right         key.Binding
        Enter         key.Binding
        Space         key.Binding
        Tab           key.Binding
        ShiftTab      key.Binding
        Delete        key.Binding
        Logs          key.Binding
        Help          key.Binding
        Quit          key.Binding
        Refresh       key.Binding
        ContextSwitch key.Binding
        SortToggle    key.Binding
}

// DefaultKeyMap returns the default key bindings
func DefaultKeyMap() KeyMap <span class="cov8" title="1">{
        return KeyMap{
                Up: key.NewBinding(
                        key.WithKeys("up", "k"),
                        key.WithHelp("↑/k", "up"),
                ),
                Down: key.NewBinding(
                        key.WithKeys("down", "j"),
                        key.WithHelp("↓/j", "down"),
                ),
                Left: key.NewBinding(
                        key.WithKeys("left", "h"),
                        key.WithHelp("←/h", "left"),
                ),
                Right: key.NewBinding(
                        key.WithKeys("right", "l"),
                        key.WithHelp("→/l", "right"),
                ),
                Enter: key.NewBinding(
                        key.WithKeys("enter"),
                        key.WithHelp("enter", "select"),
                ),
                Space: key.NewBinding(
                        key.WithKeys(" "),
                        key.WithHelp("space", "multi-select"),
                ),
                Tab: key.NewBinding(
                        key.WithKeys("tab"),
                        key.WithHelp("tab", "next resource"),
                ),
                ShiftTab: key.NewBinding(
                        key.WithKeys("shift+tab"),
                        key.WithHelp("shift+tab", "prev resource"),
                ),
                Delete: key.NewBinding(
                        key.WithKeys("delete", "D"),
                        key.WithHelp("Del/D", "delete"),
                ),
                Logs: key.NewBinding(
                        key.WithKeys("l"),
                        key.WithHelp("l", "view logs"),
                ),
                Help: key.NewBinding(
                        key.WithKeys("?"),
                        key.WithHelp("?", "help"),
                ),
                Quit: key.NewBinding(
                        key.WithKeys("q", "ctrl+c"),
                        key.WithHelp("q", "quit"),
                ),
                Refresh: key.NewBinding(
                        key.WithKeys("r", "ctrl+r"),
                        key.WithHelp("r", "refresh"),
                ),
                ContextSwitch: key.NewBinding(
                        key.WithKeys("c"),
                        key.WithHelp("c", "switch context"),
                ),
                SortToggle: key.NewBinding(
                        key.WithKeys("s"),
                        key.WithHelp("s", "sort toggle"),
                ),
        }
}</span>

// watchEventMsg represents a Kubernetes watch event
type watchEventMsg struct {
        Type   watch.EventType
        Object interface{}
}

// tickMsg represents a periodic refresh tick
type tickMsg time.Time

// App represents the main application model
type App struct {
        ctx       context.Context
        k8sClient *k8s.Client
        state     *core.State
        config    *core.Config
        keys      KeyMap

        // Multi-context support
        multiClient         *k8s.MultiContextClient
        isMultiContext      bool
        contextView         *views.ContextView
        showContextSelector bool
        activeContexts      []string

        // Views
        resourceView  *views.ResourceView
        logView       *views.LogView
        helpView      *views.HelpView
        namespaceView *views.NamespaceView
        confirmView   *views.ConfirmView
        describeView  *views.DescribeView

        // Screen mode system
        currentMode  ScreenModeType
        previousMode ScreenModeType
        modes        map[ScreenModeType]ScreenMode

        // UI state
        width              int
        height             int
        ready              bool
        showNamespacePopup bool
        showDeleteConfirm  bool
        pendingDeleteName  string
        loadingNamespaces  bool

        // Watchers
        cancelWatcher context.CancelFunc
        watcherCtx    context.Context
}

// NewApp creates a new application instance
func NewApp(ctx context.Context, k8sClient *k8s.Client, state *core.State, config *core.Config) *App <span class="cov8" title="1">{
        // Get current context for single-context mode
        var activeContexts []string
        if _, currentCtx, err := k8s.GetAvailableContexts(); err == nil &amp;&amp; currentCtx != "" </span><span class="cov8" title="1">{
                activeContexts = []string{currentCtx}
        }</span>

        <span class="cov8" title="1">app := &amp;App{
                ctx:            ctx,
                k8sClient:      k8sClient,
                state:          state,
                config:         config,
                keys:           DefaultKeyMap(),
                resourceView:   views.NewResourceView(state, k8sClient),
                logView:        views.NewLogView(),
                helpView:       views.NewHelpView(),
                isMultiContext: false,
                activeContexts: activeContexts,
                currentMode:    ModeList,
                previousMode:   ModeList,
        }

        // Initialize screen modes
        app.modes = map[ScreenModeType]ScreenMode{
                ModeList:              NewListMode(),
                ModeLog:               NewLogMode(),
                ModeDescribe:          NewDescribeMode(),
                ModeHelp:              NewHelpMode(),
                ModeContextSelector:   NewContextSelectorMode(),
                ModeNamespaceSelector: NewNamespaceSelectorMode(),
                ModeConfirmDialog:     NewConfirmDialogMode(),
        }

        return app</span>
}

// NewAppWithMultiContext creates a new application instance with multi-context support
func NewAppWithMultiContext(ctx context.Context, multiClient *k8s.MultiContextClient, state *core.State, config *core.Config) *App <span class="cov8" title="1">{
        app := &amp;App{
                ctx:            ctx,
                multiClient:    multiClient,
                state:          state,
                config:         config,
                keys:           DefaultKeyMap(),
                resourceView:   views.NewResourceViewWithMultiContext(state, multiClient),
                logView:        views.NewLogView(),
                helpView:       views.NewHelpView(),
                isMultiContext: true,
                activeContexts: state.CurrentContexts,
                currentMode:    ModeList,
                previousMode:   ModeList,
        }

        // Initialize screen modes
        app.modes = map[ScreenModeType]ScreenMode{
                ModeList:              NewListMode(),
                ModeLog:               NewLogMode(),
                ModeDescribe:          NewDescribeMode(),
                ModeHelp:              NewHelpMode(),
                ModeContextSelector:   NewContextSelectorMode(),
                ModeNamespaceSelector: NewNamespaceSelectorMode(),
                ModeConfirmDialog:     NewConfirmDialogMode(),
        }

        return app
}</span>

// Init initializes the application
func (a *App) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                a.resourceView.Init(),
                tea.EnterAltScreen,
                a.startRefreshTimer(), // Start the refresh timer
        )
}</span>

// Update handles messages
func (a *App) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tickMsg:<span class="cov0" title="0">
                // Auto-refresh on tick
                return a, tea.Batch(
                        a.resourceView.RefreshResources(),
                        a.startRefreshTimer(), // Schedule next tick
                )</span>

        case tea.KeyMsg:<span class="cov8" title="1">
                // Use the new mode system for key handling
                currentMode := a.getCurrentMode()
                handled, cmd := currentMode.HandleKey(msg, a)

                if handled </span><span class="cov8" title="1">{
                        return a, cmd
                }</span>

                // If not handled by mode, let the appropriate view handle it
                // This maintains compatibility with existing view-specific key handling
                <span class="cov8" title="1">switch a.currentMode </span>{
                case ModeList:<span class="cov8" title="1">
                        // Pass unhandled keys to resource view
                        resourceModel, viewCmd := a.resourceView.Update(msg)
                        a.resourceView = resourceModel.(*views.ResourceView)
                        return a, viewCmd</span>
                case ModeContextSelector:<span class="cov0" title="0">
                        if a.contextView != nil </span><span class="cov0" title="0">{
                                ctxModel, viewCmd := a.contextView.Update(msg)
                                a.contextView = ctxModel.(*views.ContextView)
                                return a, viewCmd
                        }</span>
                case ModeNamespaceSelector:<span class="cov0" title="0">
                        if a.namespaceView != nil </span><span class="cov0" title="0">{
                                nsModel, viewCmd := a.namespaceView.Update(msg)
                                a.namespaceView = nsModel.(*views.NamespaceView)
                                return a, viewCmd
                        }</span>
                case ModeConfirmDialog:<span class="cov0" title="0">
                        if a.confirmView != nil </span><span class="cov0" title="0">{
                                confirmModel, viewCmd := a.confirmView.Update(msg)
                                a.confirmView = confirmModel.(*views.ConfirmView)
                                return a, viewCmd
                        }</span>
                case ModeLog:<span class="cov0" title="0">
                        // Log view handles its own keys
                        logModel, viewCmd := a.logView.Update(msg)
                        a.logView = logModel.(*views.LogView)
                        return a, viewCmd</span>
                case ModeDescribe:<span class="cov0" title="0">
                        if a.describeView != nil </span><span class="cov0" title="0">{
                                describeModel, viewCmd := a.describeView.Update(msg)
                                a.describeView = describeModel.(*views.DescribeView)
                                return a, viewCmd
                        }</span>
                }

        case tea.WindowSizeMsg:<span class="cov8" title="1">
                a.width = msg.Width
                a.height = msg.Height
                a.ready = true

                // Update child views
                a.resourceView.SetSize(msg.Width, msg.Height)
                a.logView.SetSize(msg.Width, msg.Height/2)
                if a.namespaceView != nil </span><span class="cov0" title="0">{
                        a.namespaceView.SetSize(msg.Width, msg.Height)
                }</span>
                <span class="cov8" title="1">if a.confirmView != nil </span><span class="cov0" title="0">{
                        a.confirmView.SetSize(msg.Width, msg.Height)
                }</span>
                <span class="cov8" title="1">if a.contextView != nil </span><span class="cov0" title="0">{
                        a.contextView.SetSize(msg.Width, msg.Height)
                }</span>
                <span class="cov8" title="1">return a, nil</span>

        case deleteCompleteMsg:<span class="cov0" title="0">
                // Resource deleted successfully, refresh the list
                return a, a.resourceView.RefreshResources()</span>

        case views.ContextInfoMsg:<span class="cov0" title="0">
                // Show context information
                return a, a.showContextInfo(msg.ContextName)</span>

        case contextInfoDisplayMsg:<span class="cov0" title="0">
                // For now, just log the context info (in a real app, you might show a popup)
                // The context selector will remain open
                return a, nil</span>
        }

        // Update child views based on current mode
        <span class="cov8" title="1">switch a.currentMode </span>{
        case ModeHelp:<span class="cov0" title="0">
                helpModel, cmd := a.helpView.Update(msg)
                a.helpView = helpModel.(*views.HelpView)
                cmds = append(cmds, cmd)</span>

        case ModeLog:<span class="cov0" title="0">
                // Split view: only pass keyboard events to the log view
                // Resource view only gets non-keyboard messages (like refresh ticks)
                switch msg.(type) </span>{
                case tea.KeyMsg:<span class="cov0" title="0">
                        // Keyboard events go only to log view
                        logModel, cmd := a.logView.Update(msg)
                        a.logView = logModel.(*views.LogView)
                        cmds = append(cmds, cmd)</span>
                default:<span class="cov0" title="0">
                        // Non-keyboard events go to both views
                        resourceModel, cmd := a.resourceView.Update(msg)
                        a.resourceView = resourceModel.(*views.ResourceView)
                        cmds = append(cmds, cmd)

                        logModel, cmd := a.logView.Update(msg)
                        a.logView = logModel.(*views.LogView)
                        cmds = append(cmds, cmd)</span>
                }

        case ModeDescribe:<span class="cov0" title="0">
                if a.describeView != nil </span><span class="cov0" title="0">{
                        describeModel, cmd := a.describeView.Update(msg)
                        a.describeView = describeModel.(*views.DescribeView)
                        cmds = append(cmds, cmd)
                }</span>

        case ModeContextSelector:<span class="cov0" title="0">
                if a.contextView != nil </span><span class="cov0" title="0">{
                        ctxModel, cmd := a.contextView.Update(msg)
                        a.contextView = ctxModel.(*views.ContextView)
                        cmds = append(cmds, cmd)
                }</span>

        case ModeNamespaceSelector:<span class="cov0" title="0">
                if a.namespaceView != nil </span><span class="cov0" title="0">{
                        nsModel, cmd := a.namespaceView.Update(msg)
                        a.namespaceView = nsModel.(*views.NamespaceView)
                        cmds = append(cmds, cmd)
                }</span>

        case ModeConfirmDialog:<span class="cov0" title="0">
                if a.confirmView != nil </span><span class="cov0" title="0">{
                        confirmModel, cmd := a.confirmView.Update(msg)
                        a.confirmView = confirmModel.(*views.ConfirmView)
                        cmds = append(cmds, cmd)
                }</span>

        default:<span class="cov8" title="1">
                // Default to resource view (list mode)
                resourceModel, cmd := a.resourceView.Update(msg)
                a.resourceView = resourceModel.(*views.ResourceView)
                cmds = append(cmds, cmd)</span>
        }

        <span class="cov8" title="1">return a, tea.Batch(cmds...)</span>
}

// View renders the application
func (a *App) View() string <span class="cov8" title="1">{
        if !a.ready </span><span class="cov0" title="0">{
                return "Initializing..."
        }</span>

        // Render based on current mode
        <span class="cov8" title="1">switch a.currentMode </span>{
        case ModeConfirmDialog:<span class="cov0" title="0">
                if a.confirmView != nil </span><span class="cov0" title="0">{
                        return a.confirmView.View()
                }</span>

        case ModeNamespaceSelector:<span class="cov0" title="0">
                if a.namespaceView != nil </span><span class="cov0" title="0">{
                        return a.namespaceView.View()
                }</span>

        case ModeContextSelector:<span class="cov0" title="0">
                if a.contextView != nil </span><span class="cov0" title="0">{
                        return a.contextView.View()
                }</span>

        case ModeHelp:<span class="cov8" title="1">
                return a.helpView.View()</span>

        case ModeDescribe:<span class="cov0" title="0">
                if a.describeView != nil </span><span class="cov0" title="0">{
                        return a.describeView.View()
                }</span>

        case ModeLog:<span class="cov0" title="0">
                // Split view - give more space to logs, keep resource view compact
                minResourceHeight := 8 // Minimum height for resource view (header + 5-6 rows)
                resourceHeight := minResourceHeight

                // If we have more space, show a bit more context
                if a.height &gt; 20 </span><span class="cov0" title="0">{
                        resourceHeight = a.height / 3 // Give 1/3 to resources, 2/3 to logs
                        if resourceHeight &lt; minResourceHeight </span><span class="cov0" title="0">{
                                resourceHeight = minResourceHeight
                        }</span>
                }

                <span class="cov0" title="0">logHeight := a.height - resourceHeight - 1

                // Update sizes for both views
                a.resourceView.SetSize(a.width, resourceHeight)
                a.logView.SetSize(a.width, logHeight)

                topView := lipgloss.NewStyle().
                        Height(resourceHeight).
                        MaxHeight(resourceHeight).
                        Render(a.resourceView.View())

                bottomView := lipgloss.NewStyle().
                        Height(logHeight).
                        BorderTop(true).
                        BorderStyle(lipgloss.NormalBorder()).
                        Render(a.logView.View())

                return lipgloss.JoinVertical(lipgloss.Left, topView, bottomView)</span>
        }

        // Default to list mode (resource view)
        <span class="cov8" title="1">return a.resourceView.View()</span>
}

// nextResourceType cycles to the next resource type
func (a *App) nextResourceType() <span class="cov8" title="1">{
        types := []core.ResourceType{
                core.ResourceTypePod,
                core.ResourceTypeDeployment,
                core.ResourceTypeStatefulSet,
                core.ResourceTypeService,
                core.ResourceTypeIngress,
                core.ResourceTypeConfigMap,
                core.ResourceTypeSecret,
        }

        current := a.state.CurrentResourceType
        for i, t := range types </span><span class="cov8" title="1">{
                if t == current </span><span class="cov8" title="1">{
                        next := types[(i+1)%len(types)]
                        a.state.SetResourceType(next)
                        return
                }</span>
        }
}

// prevResourceType cycles to the previous resource type
func (a *App) prevResourceType() <span class="cov8" title="1">{
        types := []core.ResourceType{
                core.ResourceTypePod,
                core.ResourceTypeDeployment,
                core.ResourceTypeStatefulSet,
                core.ResourceTypeService,
                core.ResourceTypeIngress,
                core.ResourceTypeConfigMap,
                core.ResourceTypeSecret,
        }

        current := a.state.CurrentResourceType
        for i, t := range types </span><span class="cov8" title="1">{
                if t == current </span><span class="cov8" title="1">{
                        prev := types[(i-1+len(types))%len(types)]
                        a.state.SetResourceType(prev)
                        return
                }</span>
        }
}

// startWatcher starts watching for resource changes
func (a *App) startWatcher() tea.Cmd <span class="cov0" title="0">{
        // Cancel any existing watcher
        if a.cancelWatcher != nil </span><span class="cov0" title="0">{
                a.cancelWatcher()
        }</span>

        // Create new context for watcher
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(a.ctx)
        a.watcherCtx = ctx
        a.cancelWatcher = cancel

        return func() tea.Msg </span><span class="cov0" title="0">{
                // Start watcher based on current resource type
                var watcher watch.Interface
                var err error

                switch a.state.CurrentResourceType </span>{
                case core.ResourceTypePod:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchPods(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeDeployment:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchDeployments(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchStatefulSets(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeService:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchServices(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeIngress:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchIngresses(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeConfigMap:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchConfigMaps(ctx, a.state.CurrentNamespace)</span>
                case core.ResourceTypeSecret:<span class="cov0" title="0">
                        watcher, err = a.k8sClient.WatchSecrets(ctx, a.state.CurrentNamespace)</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil // Silently fail for now
                }</span>

                // Watch for events
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        defer watcher.Stop()
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case _, ok := &lt;-watcher.ResultChan():<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        // For now, just trigger a refresh
                                        // In a full implementation, we'd send the event as a message
                                }
                        }
                }()

                <span class="cov0" title="0">return nil</span>
        }
}

// startRefreshTimer returns a command that sends a tick message after the configured interval
func (a *App) startRefreshTimer() tea.Cmd <span class="cov0" title="0">{
        interval := time.Duration(a.config.RefreshInterval) * time.Second
        return tea.Tick(interval, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return tickMsg(t)
        }</span>)
}

// openNamespaceSelector opens the namespace selection popup
func (a *App) openNamespaceSelector() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if a.k8sClient == nil </span><span class="cov0" title="0">{
                        return errMsg{fmt.Errorf("no kubernetes client available")}
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                namespaces, err := a.k8sClient.ListNamespaces(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Return error message
                        return errMsg{err}
                }</span>

                // Create namespace view
                <span class="cov0" title="0">a.namespaceView = views.NewNamespaceView(namespaces, a.state.CurrentNamespace)
                a.namespaceView.SetSize(a.width, a.height)
                a.showNamespacePopup = true

                return nil</span>
        }
}

// openContextSelector opens the context selection popup
func (a *App) openContextSelector() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Get available contexts
                contexts, _, err := k8s.GetAvailableContexts()
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Create context view with current selections
                <span class="cov0" title="0">a.contextView = views.NewContextView(contexts, a.activeContexts)
                a.contextView.SetSize(a.width, a.height)
                a.showContextSelector = true
                a.setMode(ModeContextSelector)

                return nil</span>
        }
}

// getSelectedResourceContext returns the context of the currently selected resource in multi-context mode
func (a *App) getSelectedResourceContext() string <span class="cov0" title="0">{
        if !a.isMultiContext </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return a.resourceView.GetSelectedResourceContext()</span>
}

// cycleSortColumn cycles through available sort columns or toggles sort direction
func (a *App) cycleSortColumn() <span class="cov8" title="1">{
        // Get available columns for current resource type
        availableColumns := a.getAvailableSortColumns()

        currentColumn := a.state.SortColumn
        if currentColumn == "" </span><span class="cov8" title="1">{
                currentColumn = "NAME"
        }</span>

        // Find current column index
        <span class="cov8" title="1">currentIndex := -1
        for i, col := range availableColumns </span><span class="cov8" title="1">{
                if col == currentColumn </span><span class="cov8" title="1">{
                        currentIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentIndex == -1 </span><span class="cov0" title="0">{
                // Column not found, start with first column
                a.state.SortColumn = availableColumns[0]
                a.state.SortAscending = true
        }</span> else<span class="cov8" title="1"> if currentIndex == len(availableColumns)-1 </span><span class="cov8" title="1">{
                // Last column, toggle direction
                a.state.SortAscending = !a.state.SortAscending
        }</span> else<span class="cov8" title="1"> {
                // Move to next column
                a.state.SortColumn = availableColumns[currentIndex+1]
                a.state.SortAscending = true
        }</span>
}

// getAvailableSortColumns returns the sortable columns for the current resource type
func (a *App) getAvailableSortColumns() []string <span class="cov8" title="1">{
        switch a.state.CurrentResourceType </span>{
        case core.ResourceTypePod:<span class="cov8" title="1">
                if a.isMultiContext </span><span class="cov0" title="0">{
                        return []string{"CONTEXT", "NAME", "READY", "STATUS", "RESTARTS", "AGE"}
                }</span>
                <span class="cov8" title="1">return []string{"NAME", "READY", "STATUS", "RESTARTS", "AGE"}</span>
        case core.ResourceTypeDeployment:<span class="cov0" title="0">
                if a.isMultiContext </span><span class="cov0" title="0">{
                        return []string{"CONTEXT", "NAME", "READY", "UP-TO-DATE", "AVAILABLE", "AGE"}
                }</span>
                <span class="cov0" title="0">return []string{"NAME", "READY", "UP-TO-DATE", "AVAILABLE", "AGE"}</span>
        case core.ResourceTypeService:<span class="cov0" title="0">
                if a.isMultiContext </span><span class="cov0" title="0">{
                        return []string{"CONTEXT", "NAME", "TYPE", "CLUSTER-IP", "AGE"}
                }</span>
                <span class="cov0" title="0">return []string{"NAME", "TYPE", "CLUSTER-IP", "AGE"}</span>
        default:<span class="cov0" title="0">
                if a.isMultiContext </span><span class="cov0" title="0">{
                        return []string{"CONTEXT", "NAME", "AGE"}
                }</span>
                <span class="cov0" title="0">return []string{"NAME", "AGE"}</span>
        }
}

// Mode management methods

// setMode changes the current screen mode
func (a *App) setMode(mode ScreenModeType) <span class="cov8" title="1">{
        a.previousMode = a.currentMode
        a.currentMode = mode

        // Update legacy state flags for compatibility
        switch mode </span>{
        case ModeHelp:<span class="cov8" title="1">
                a.state.ShowHelp = true</span>
        case ModeLog:<span class="cov8" title="1">
                a.state.ShowLogs = true</span>
        case ModeContextSelector:<span class="cov8" title="1">
                a.showContextSelector = true</span>
        case ModeNamespaceSelector:<span class="cov8" title="1">
                a.showNamespacePopup = true</span>
        case ModeConfirmDialog:<span class="cov0" title="0">
                a.showDeleteConfirm = true</span>
        default:<span class="cov8" title="1">
                // Clear all legacy flags when returning to list mode
                a.state.ShowHelp = false
                a.state.ShowLogs = false
                a.showContextSelector = false
                a.showNamespacePopup = false
                a.showDeleteConfirm = false</span>
        }
}

// returnToPreviousMode returns to the previous screen mode
func (a *App) returnToPreviousMode() <span class="cov8" title="1">{
        a.setMode(a.previousMode)
}</span>

// getCurrentMode returns the current screen mode handler
func (a *App) getCurrentMode() ScreenMode <span class="cov8" title="1">{
        if mode, exists := a.modes[a.currentMode]; exists </span><span class="cov8" title="1">{
                return mode
        }</span>
        <span class="cov0" title="0">return a.modes[ModeList]</span> // fallback
}

// Mode-specific action methods

// startDescribeView starts the describe view for a resource
func (a *App) startDescribeView(resourceName string) tea.Cmd <span class="cov0" title="0">{
        resourceType := string(a.state.CurrentResourceType)
        namespace := a.state.CurrentNamespace
        context := ""

        if a.isMultiContext </span><span class="cov0" title="0">{
                context = a.getSelectedResourceContext()
        }</span>

        <span class="cov0" title="0">a.describeView = views.NewDescribeView(resourceType, resourceName, namespace, context)
        a.describeView.SetSize(a.width, a.height)

        // Use the appropriate client
        if a.isMultiContext &amp;&amp; context != "" </span><span class="cov0" title="0">{
                if client, err := a.multiClient.GetClient(context); err == nil </span><span class="cov0" title="0">{
                        return a.describeView.LoadDescribeWithClient(a.ctx, client)
                }</span>
        } else<span class="cov0" title="0"> if a.k8sClient != nil </span><span class="cov0" title="0">{
                return a.describeView.LoadDescribeWithClient(a.ctx, a.k8sClient)
        }</span>

        // Fallback to placeholder content
        <span class="cov0" title="0">return a.describeView.Init()</span>
}

// showDeleteConfirmation shows the delete confirmation dialog
func (a *App) showDeleteConfirmation(resourceName string) tea.Cmd <span class="cov0" title="0">{
        a.pendingDeleteName = resourceName
        resourceType := string(a.state.CurrentResourceType)

        // Remove the 's' at the end for singular form
        if strings.HasSuffix(resourceType, "s") </span><span class="cov0" title="0">{
                resourceType = resourceType[:len(resourceType)-1]
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("Are you sure you want to delete %s '%s'?",
                strings.ToLower(resourceType), resourceName)
        a.confirmView = views.NewConfirmView("⚠️  Confirm Deletion", message)
        a.confirmView.SetSize(a.width, a.height)
        a.confirmView.SetConfirmText("Delete")
        a.confirmView.SetCancelText("Cancel")

        return nil</span>
}

// applyContextSelection applies the selected contexts
func (a *App) applyContextSelection() tea.Cmd <span class="cov8" title="1">{
        if a.contextView == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">newContexts := a.contextView.GetSelectedContexts()
        if len(newContexts) &gt; 0 </span><span class="cov0" title="0">{
                a.activeContexts = newContexts
                a.state.SetCurrentContexts(newContexts)

                if len(newContexts) == 1 </span><span class="cov0" title="0">{
                        // Single context mode - create a single client
                        singleClient, err := k8s.NewClientWithOptions("", &amp;k8s.ClientOptions{
                                Context: newContexts[0],
                        })
                        if err == nil </span><span class="cov0" title="0">{
                                a.k8sClient = singleClient
                                a.multiClient = nil
                                a.isMultiContext = false
                                // Update resource view with single client
                                a.resourceView = views.NewResourceView(a.state, singleClient)
                                a.resourceView.SetSize(a.width, a.height)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Multi-context mode - create multi-client
                        multiClient, err := k8s.NewMultiContextClient(newContexts)
                        if err == nil </span><span class="cov0" title="0">{
                                a.multiClient = multiClient
                                a.k8sClient = nil
                                a.isMultiContext = true
                                // Update resource view with multi-client
                                a.resourceView = views.NewResourceViewWithMultiContext(a.state, multiClient)
                                a.resourceView.SetSize(a.width, a.height)
                        }</span>
                }

                // Refresh resources with new contexts
                <span class="cov0" title="0">a.setMode(ModeList)
                return a.resourceView.RefreshResources()</span>
        }
        <span class="cov0" title="0">a.setMode(ModeList)
        return nil</span>
}

// applyNamespaceSelection applies the selected namespace
func (a *App) applyNamespaceSelection() tea.Cmd <span class="cov0" title="0">{
        newNamespace := a.namespaceView.GetSelectedNamespace()
        if newNamespace != a.state.CurrentNamespace </span><span class="cov0" title="0">{
                a.state.CurrentNamespace = newNamespace
                a.config.CurrentNamespace = newNamespace
                // Refresh resources with new namespace
                a.setMode(ModeList)
                return a.resourceView.RefreshResources()
        }</span>
        <span class="cov0" title="0">a.setMode(ModeList)
        return nil</span>
}

// handleConfirmDialogAction handles the confirm dialog action
func (a *App) handleConfirmDialogAction() tea.Cmd <span class="cov0" title="0">{
        if a.confirmView.IsConfirmed() </span><span class="cov0" title="0">{
                // Proceed with deletion
                a.setMode(ModeList)
                return a.resourceView.DeleteSelected()
        }</span>
        // Cancelled
        <span class="cov0" title="0">a.setMode(ModeList)
        a.pendingDeleteName = ""
        return nil</span>
}

// showContextInfo displays detailed information about a context
func (a *App) showContextInfo(contextName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Get context information
                contexts, currentCtx, err := k8s.GetAvailableContexts()
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Find the context details
                <span class="cov0" title="0">info := fmt.Sprintf("Context: %s\n", contextName)
                if contextName == currentCtx </span><span class="cov0" title="0">{
                        info += "Status: Current context\n"
                }</span> else<span class="cov0" title="0"> {
                        info += "Status: Available\n"
                }</span>

                // Add more context details here if available
                <span class="cov0" title="0">info += fmt.Sprintf("Total contexts available: %d\n", len(contexts))

                // For now, just show a simple info message
                // In a real implementation, you might want to create a dedicated info view
                return contextInfoDisplayMsg{
                        contextName: contextName,
                        info:        info,
                }</span>
        }
}

// Message types
type errMsg struct{ err error }
type deleteCompleteMsg struct{ name string }
type contextSelectionMsg struct{ contexts []string }
type contextInfoDisplayMsg struct {
        contextName string
        info        string
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ui

import (
        "github.com/HamStudy/kubewatch/internal/k8s"
        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
)

// ScreenModeType represents different screen modes
type ScreenModeType int

const (
        ModeList ScreenModeType = iota
        ModeLog
        ModeDescribe
        ModeHelp
        ModeContextSelector
        ModeNamespaceSelector
        ModeConfirmDialog
)

// KeyBinding represents a key binding with help text
type KeyBinding struct {
        Key         key.Binding
        Description string
        Section     string // For grouping in help
}

// ScreenMode defines the interface for different screen modes
type ScreenMode interface {
        // GetType returns the mode type
        GetType() ScreenModeType

        // GetKeyBindings returns the key bindings for this mode
        GetKeyBindings() map[string]KeyBinding

        // HandleKey processes a key message and returns whether it was handled
        HandleKey(msg tea.KeyMsg, app *App) (handled bool, cmd tea.Cmd)

        // GetHelpSections returns organized help sections for this mode
        GetHelpSections() map[string][]KeyBinding

        // GetTitle returns the title for this mode (used in help)
        GetTitle() string
}

// BaseMode provides common functionality for screen modes
type BaseMode struct {
        modeType ScreenModeType
        title    string
}

func (m *BaseMode) GetType() ScreenModeType <span class="cov8" title="1">{
        return m.modeType
}</span>

func (m *BaseMode) GetTitle() string <span class="cov8" title="1">{
        return m.title
}</span>

// Helper function to create key bindings
func NewKeyBinding(keys []string, help string, description string, section string) KeyBinding <span class="cov8" title="1">{
        return KeyBinding{
                Key: key.NewBinding(
                        key.WithKeys(keys...),
                        key.WithHelp(help, description),
                ),
                Description: description,
                Section:     section,
        }
}</span>

// ListMode handles the main resource list view
type ListMode struct {
        BaseMode
}

func NewListMode() *ListMode <span class="cov8" title="1">{
        return &amp;ListMode{
                BaseMode: BaseMode{
                        modeType: ModeList,
                        title:    "KubeWatch TUI - Resource View",
                },
        }
}</span>

func (m *ListMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "up":        NewKeyBinding([]string{"up", "k"}, "↑/k", "Move up", "Navigation"),
                "down":      NewKeyBinding([]string{"down", "j"}, "↓/j", "Move down", "Navigation"),
                "left":      NewKeyBinding([]string{"left", "h"}, "←/h", "Move left", "Navigation"),
                "right":     NewKeyBinding([]string{"right", "l"}, "→/l", "Move right", "Navigation"),
                "tab":       NewKeyBinding([]string{"tab"}, "Tab", "Next resource type", "Navigation"),
                "shift+tab": NewKeyBinding([]string{"shift+tab"}, "S-Tab", "Previous resource type", "Navigation"),
                "namespace": NewKeyBinding([]string{"n"}, "n", "Change namespace", "Navigation"),
                "context":   NewKeyBinding([]string{"c"}, "c", "Switch contexts", "Navigation"),
                "enter":     NewKeyBinding([]string{"enter"}, "Enter", "Select/View logs", "Actions"),
                "logs":      NewKeyBinding([]string{"l"}, "l", "View logs", "Actions"),
                "info":      NewKeyBinding([]string{"i"}, "i", "Show resource info", "Actions"),
                "describe":  NewKeyBinding([]string{"d"}, "d", "Describe resource", "Actions"),
                "delete":    NewKeyBinding([]string{"delete", "D"}, "Del/D", "Delete resource", "Actions"),
                "refresh":   NewKeyBinding([]string{"r", "ctrl+r"}, "r", "Refresh", "Actions"),
                "sort":      NewKeyBinding([]string{"s"}, "s", "Cycle sort column/direction", "Actions"),
                "help":      NewKeyBinding([]string{"?"}, "?", "Toggle help", "General"),
                "quit":      NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit", "General"),
                "escape":    NewKeyBinding([]string{"esc"}, "Esc", "Close dialog/Back", "General"),
        }
}</span>

func (m *ListMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *ListMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov8" title="1">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["help"].Key):<span class="cov8" title="1">
                app.setMode(ModeHelp)
                return true, nil</span>

        case key.Matches(msg, bindings["namespace"].Key):<span class="cov8" title="1">
                return true, app.openNamespaceSelector()</span>

        case key.Matches(msg, bindings["context"].Key):<span class="cov8" title="1">
                return true, app.openContextSelector()</span>

        case key.Matches(msg, bindings["tab"].Key):<span class="cov8" title="1">
                app.nextResourceType()
                return true, app.resourceView.RefreshResources()</span>

        case key.Matches(msg, bindings["shift+tab"].Key):<span class="cov8" title="1">
                app.prevResourceType()
                return true, app.resourceView.RefreshResources()</span>

        case key.Matches(msg, bindings["logs"].Key), key.Matches(msg, bindings["enter"].Key):<span class="cov8" title="1">
                selectedName := app.resourceView.GetSelectedResourceName()
                if selectedName != "" </span><span class="cov0" title="0">{
                        // Get the appropriate client for logs
                        var client *k8s.Client
                        if app.isMultiContext </span><span class="cov0" title="0">{
                                contextName := app.getSelectedResourceContext()
                                if contextName != "" </span><span class="cov0" title="0">{
                                        client, _ = app.multiClient.GetClient(contextName)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                client = app.k8sClient
                        }</span>

                        // Only proceed if we have a valid client
                        <span class="cov0" title="0">if client != nil </span><span class="cov0" title="0">{
                                app.setMode(ModeLog)
                                app.resourceView.SetCompactMode(true)
                                return true, app.logView.StartStreaming(app.ctx, client, app.state, selectedName)
                        }</span>
                }
        case key.Matches(msg, bindings["info"].Key):<span class="cov8" title="1">
                selectedName := app.resourceView.GetSelectedResourceName()
                if selectedName != "" </span><span class="cov0" title="0">{
                        // Check if we have a valid client before proceeding
                        var hasClient bool
                        if app.isMultiContext </span><span class="cov0" title="0">{
                                contextName := app.getSelectedResourceContext()
                                if contextName != "" </span><span class="cov0" title="0">{
                                        _, err := app.multiClient.GetClient(contextName)
                                        hasClient = err == nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                hasClient = app.k8sClient != nil
                        }</span>

                        <span class="cov0" title="0">if hasClient </span><span class="cov0" title="0">{
                                app.setMode(ModeDescribe)
                                return true, app.startDescribeView(selectedName)
                        }</span>
                }
                <span class="cov8" title="1">return true, nil</span> // Always handle the key, even if we can't process it

        case key.Matches(msg, bindings["describe"].Key):<span class="cov8" title="1">
                selectedName := app.resourceView.GetSelectedResourceName()
                if selectedName != "" </span><span class="cov0" title="0">{
                        // Check if we have a valid client before proceeding
                        var hasClient bool
                        if app.isMultiContext </span><span class="cov0" title="0">{
                                contextName := app.getSelectedResourceContext()
                                if contextName != "" </span><span class="cov0" title="0">{
                                        _, err := app.multiClient.GetClient(contextName)
                                        hasClient = err == nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                hasClient = app.k8sClient != nil
                        }</span>

                        <span class="cov0" title="0">if hasClient </span><span class="cov0" title="0">{
                                app.setMode(ModeDescribe)
                                return true, app.startDescribeView(selectedName)
                        }</span>
                }
                <span class="cov8" title="1">return true, nil</span> // Always handle the key, even if we can't process it

        case key.Matches(msg, bindings["delete"].Key):<span class="cov8" title="1">
                selectedName := app.resourceView.GetSelectedResourceName()
                if selectedName != "" </span><span class="cov0" title="0">{
                        app.setMode(ModeConfirmDialog)
                        return true, app.showDeleteConfirmation(selectedName)
                }</span>

        case key.Matches(msg, bindings["refresh"].Key):<span class="cov8" title="1">
                return true, app.resourceView.RefreshResources()</span>

        case key.Matches(msg, bindings["sort"].Key):<span class="cov8" title="1">
                app.cycleSortColumn()
                return true, app.resourceView.RefreshResources()</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// LogMode handles the log view
type LogMode struct {
        BaseMode
}

func NewLogMode() *LogMode <span class="cov8" title="1">{
        return &amp;LogMode{
                BaseMode: BaseMode{
                        modeType: ModeLog,
                        title:    "KubeWatch TUI - Log View",
                },
        }
}</span>

func (m *LogMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "up":        NewKeyBinding([]string{"up", "k"}, "↑/k", "Scroll up", "Navigation"),
                "down":      NewKeyBinding([]string{"down", "j"}, "↓/j", "Scroll down", "Navigation"),
                "pageup":    NewKeyBinding([]string{"pgup"}, "PgUp", "Page up", "Navigation"),
                "pagedown":  NewKeyBinding([]string{"pgdown"}, "PgDn", "Page down", "Navigation"),
                "home":      NewKeyBinding([]string{"home", "g"}, "Home/g", "Jump to top", "Navigation"),
                "end":       NewKeyBinding([]string{"end", "G"}, "End/G", "Jump to bottom (follow)", "Navigation"),
                "follow":    NewKeyBinding([]string{"f"}, "f", "Toggle follow mode", "Log Controls"),
                "search":    NewKeyBinding([]string{"/"}, "/", "Search in logs", "Log Controls"),
                "container": NewKeyBinding([]string{"c"}, "c", "Cycle containers", "Log Controls"),
                "pod":       NewKeyBinding([]string{"p"}, "p", "Cycle pods", "Log Controls"),
                "clear":     NewKeyBinding([]string{"C"}, "C", "Clear log buffer", "Log Controls"),
                "help":      NewKeyBinding([]string{"?"}, "?", "Toggle help", "General"),
                "quit":      NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape":    NewKeyBinding([]string{"esc"}, "Esc", "Close logs", "General"),
        }
}</span>

func (m *LogMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *LogMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        // When in search mode, only handle ESC and let log view handle everything else
        if app.logView.IsSearchMode() </span><span class="cov0" title="0">{
                if key.Matches(msg, bindings["escape"].Key) </span><span class="cov0" title="0">{
                        // Let log view handle search cancellation
                        return false, nil
                }</span>
                // Skip all other app-level key processing when in search mode
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov8" title="1">switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["help"].Key):<span class="cov8" title="1">
                app.setMode(ModeHelp)
                return true, nil</span>

        case key.Matches(msg, bindings["escape"].Key):<span class="cov8" title="1">
                app.setMode(ModeList)
                app.resourceView.SetCompactMode(false)
                app.resourceView.SetSize(app.width, app.height)
                return true, app.logView.StopStreaming()</span>
        }

        // Let log view handle all other keys
        <span class="cov0" title="0">return false, nil</span>
}

// DescribeMode handles the kubectl describe view
type DescribeMode struct {
        BaseMode
}

func NewDescribeMode() *DescribeMode <span class="cov8" title="1">{
        return &amp;DescribeMode{
                BaseMode: BaseMode{
                        modeType: ModeDescribe,
                        title:    "KubeWatch TUI - Describe View",
                },
        }
}</span>

func (m *DescribeMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "up":       NewKeyBinding([]string{"up", "k"}, "↑/k", "Scroll up", "Navigation"),
                "down":     NewKeyBinding([]string{"down", "j"}, "↓/j", "Scroll down", "Navigation"),
                "pageup":   NewKeyBinding([]string{"pgup"}, "PgUp", "Page up", "Navigation"),
                "pagedown": NewKeyBinding([]string{"pgdown"}, "PgDn", "Page down", "Navigation"),
                "home":     NewKeyBinding([]string{"home", "g"}, "Home/g", "Jump to top", "Navigation"),
                "end":      NewKeyBinding([]string{"end", "G"}, "End/G", "Jump to bottom", "Navigation"),
                "help":     NewKeyBinding([]string{"?"}, "?", "Toggle help", "General"),
                "quit":     NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape":   NewKeyBinding([]string{"esc"}, "Esc", "Back to list", "General"),
        }
}</span>

func (m *DescribeMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *DescribeMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["help"].Key):<span class="cov8" title="1">
                app.setMode(ModeHelp)
                return true, nil</span>

        case key.Matches(msg, bindings["escape"].Key):<span class="cov8" title="1">
                app.setMode(ModeList)
                return true, nil</span>
        }

        // Let describe view handle all other keys
        <span class="cov0" title="0">return false, nil</span>
}

// HelpMode handles the help view
type HelpMode struct {
        BaseMode
}

func NewHelpMode() *HelpMode <span class="cov8" title="1">{
        return &amp;HelpMode{
                BaseMode: BaseMode{
                        modeType: ModeHelp,
                        title:    "KubeWatch TUI - Help",
                },
        }
}</span>

func (m *HelpMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "help":   NewKeyBinding([]string{"?"}, "?", "Close help", "General"),
                "quit":   NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape": NewKeyBinding([]string{"esc"}, "Esc", "Close help", "General"),
        }
}</span>

func (m *HelpMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *HelpMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["help"].Key), key.Matches(msg, bindings["escape"].Key):<span class="cov8" title="1">
                app.returnToPreviousMode()
                return true, nil</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// ContextSelectorMode handles context selection
type ContextSelectorMode struct {
        BaseMode
}

func NewContextSelectorMode() *ContextSelectorMode <span class="cov8" title="1">{
        return &amp;ContextSelectorMode{
                BaseMode: BaseMode{
                        modeType: ModeContextSelector,
                        title:    "KubeWatch TUI - Context Selector",
                },
        }
}</span>

func (m *ContextSelectorMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "up":     NewKeyBinding([]string{"up", "k"}, "↑/k", "Move up", "Navigation"),
                "down":   NewKeyBinding([]string{"down", "j"}, "↓/j", "Move down", "Navigation"),
                "space":  NewKeyBinding([]string{" "}, "Space", "Toggle selection", "Actions"),
                "enter":  NewKeyBinding([]string{"enter"}, "Enter", "Apply selection", "Actions"),
                "quit":   NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape": NewKeyBinding([]string{"esc", "c"}, "Esc/c", "Cancel", "General"),
        }
}</span>

func (m *ContextSelectorMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *ContextSelectorMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["enter"].Key):<span class="cov8" title="1">
                return true, app.applyContextSelection()</span>

        case key.Matches(msg, bindings["escape"].Key):<span class="cov8" title="1">
                app.setMode(ModeList)
                return true, nil</span>
        }

        // Let context view handle navigation keys
        <span class="cov0" title="0">return false, nil</span>
}

// NamespaceSelectorMode handles namespace selection
type NamespaceSelectorMode struct {
        BaseMode
}

func NewNamespaceSelectorMode() *NamespaceSelectorMode <span class="cov8" title="1">{
        return &amp;NamespaceSelectorMode{
                BaseMode: BaseMode{
                        modeType: ModeNamespaceSelector,
                        title:    "KubeWatch TUI - Namespace Selector",
                },
        }
}</span>

func (m *NamespaceSelectorMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "up":     NewKeyBinding([]string{"up", "k"}, "↑/k", "Move up", "Navigation"),
                "down":   NewKeyBinding([]string{"down", "j"}, "↓/j", "Move down", "Navigation"),
                "enter":  NewKeyBinding([]string{"enter"}, "Enter", "Select namespace", "Actions"),
                "quit":   NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape": NewKeyBinding([]string{"esc", "n"}, "Esc/n", "Cancel", "General"),
        }
}</span>

func (m *NamespaceSelectorMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *NamespaceSelectorMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["enter"].Key):<span class="cov0" title="0">
                return true, app.applyNamespaceSelection()</span>

        case key.Matches(msg, bindings["escape"].Key):<span class="cov8" title="1">
                app.setMode(ModeList)
                return true, nil</span>
        }

        // Let namespace view handle navigation keys
        <span class="cov0" title="0">return false, nil</span>
}

// ConfirmDialogMode handles confirmation dialogs
type ConfirmDialogMode struct {
        BaseMode
}

func NewConfirmDialogMode() *ConfirmDialogMode <span class="cov8" title="1">{
        return &amp;ConfirmDialogMode{
                BaseMode: BaseMode{
                        modeType: ModeConfirmDialog,
                        title:    "KubeWatch TUI - Confirmation",
                },
        }
}</span>

func (m *ConfirmDialogMode) GetKeyBindings() map[string]KeyBinding <span class="cov8" title="1">{
        return map[string]KeyBinding{
                "left":   NewKeyBinding([]string{"left", "h"}, "←/h", "Move left", "Navigation"),
                "right":  NewKeyBinding([]string{"right", "l"}, "→/l", "Move right", "Navigation"),
                "enter":  NewKeyBinding([]string{"enter", " "}, "Enter/Space", "Confirm selection", "Actions"),
                "quit":   NewKeyBinding([]string{"q", "ctrl+c"}, "q", "Quit application", "General"),
                "escape": NewKeyBinding([]string{"esc"}, "Esc", "Cancel", "General"),
        }
}</span>

func (m *ConfirmDialogMode) GetHelpSections() map[string][]KeyBinding <span class="cov8" title="1">{
        bindings := m.GetKeyBindings()
        sections := make(map[string][]KeyBinding)

        for _, binding := range bindings </span><span class="cov8" title="1">{
                sections[binding.Section] = append(sections[binding.Section], binding)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

func (m *ConfirmDialogMode) HandleKey(msg tea.KeyMsg, app *App) (bool, tea.Cmd) <span class="cov0" title="0">{
        bindings := m.GetKeyBindings()

        switch </span>{
        case key.Matches(msg, bindings["quit"].Key):<span class="cov0" title="0">
                return true, tea.Quit</span>

        case key.Matches(msg, bindings["enter"].Key):<span class="cov0" title="0">
                return true, app.handleConfirmDialogAction()</span>

        case key.Matches(msg, bindings["escape"].Key):<span class="cov0" title="0">
                app.setMode(ModeList)
                return true, nil</span>
        }

        // Let confirm view handle navigation keys
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ui

import (
        "context"
        "testing"

        "github.com/HamStudy/kubewatch/internal/core"
        tea "github.com/charmbracelet/bubbletea"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// createTestApp creates a test app with minimal setup for testing UI logic
func createTestApp(t *testing.T) *App <span class="cov8" title="1">{
        state := &amp;core.State{
                CurrentResourceType: core.ResourceTypePod,
                CurrentNamespace:    "default",
                CurrentContext:      "test-context",
        }

        config := &amp;core.Config{
                RefreshInterval: 5,
        }

        // Create app with nil client for pure UI testing
        app := NewApp(context.Background(), nil, state, config)
        app.width = 80
        app.height = 24
        app.ready = true

        return app
}</span>

// createMockPod creates a mock pod for testing
func createMockPod(name, phase, namespace string) *v1.Pod <span class="cov0" title="0">{
        return &amp;v1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        UID:       types.UID("mock-uid-" + name),
                },
                Status: v1.PodStatus{
                        Phase: v1.PodPhase(phase),
                },
                Spec: v1.PodSpec{
                        Containers: []v1.Container{
                                {Name: "main", Image: "nginx:latest"},
                        },
                },
        }
}</span>

// createMockDeployment creates a mock deployment for testing
func createMockDeployment(name, namespace string) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":      name,
                "namespace": namespace,
                "replicas":  3,
                "ready":     2,
        }
}</span>

// createMockService creates a mock service for testing
func createMockService(name, namespace string) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":      name,
                "namespace": namespace,
                "type":      "ClusterIP",
                "ports":     []string{"80:8080/TCP"},
        }
}</span>

// simulateKeyPress simulates a key press and returns the updated model and command
func simulateKeyPress(app *App, key string) (*App, tea.Cmd) <span class="cov0" title="0">{
        var keyMsg tea.KeyMsg

        switch key </span>{
        case "up":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyUp}</span>
        case "down":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyDown}</span>
        case "left":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyLeft}</span>
        case "right":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyRight}</span>
        case "enter":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyEnter}</span>
        case "esc":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyEsc}</span>
        case "tab":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeyTab}</span>
        case "space":<span class="cov0" title="0">
                keyMsg = tea.KeyMsg{Type: tea.KeySpace}</span>
        default:<span class="cov0" title="0">
                // Handle single character keys
                keyMsg = tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(key)}</span>
        }

        <span class="cov0" title="0">model, cmd := app.Update(keyMsg)
        return model.(*App), cmd</span>
}

// assertMode checks that the app is in the expected mode
func assertMode(t *testing.T, app *App, expectedMode ScreenModeType) <span class="cov0" title="0">{
        t.Helper()
        if app.currentMode != expectedMode </span><span class="cov0" title="0">{
                t.Errorf("Expected mode %v, got %v", expectedMode, app.currentMode)
        }</span>
}

// assertViewContains checks that the view contains the expected text
func assertViewContains(t *testing.T, app *App, expectedText string) <span class="cov0" title="0">{
        t.Helper()
        view := app.View()
        if !containsText(view, expectedText) </span><span class="cov0" title="0">{
                t.Errorf("Expected view to contain '%s', but it didn't.\nActual view:\n%s", expectedText, view)
        }</span>
}

// assertViewNotContains checks that the view does not contain the specified text
func assertViewNotContains(t *testing.T, app *App, unexpectedText string) <span class="cov0" title="0">{
        t.Helper()
        view := app.View()
        if containsText(view, unexpectedText) </span><span class="cov0" title="0">{
                t.Errorf("Expected view to NOT contain '%s', but it did.\nActual view:\n%s", unexpectedText, view)
        }</span>
}

// containsText checks if the view contains the specified text (case-insensitive)
func containsText(view, text string) bool <span class="cov0" title="0">{
        // Simple substring check - could be enhanced with regex or fuzzy matching
        return len(view) &gt; 0 &amp;&amp; len(text) &gt; 0 &amp;&amp;
                (view == text || findSubstring(view, text))
}</span>

// findSubstring performs a simple substring search
func findSubstring(haystack, needle string) bool <span class="cov0" title="0">{
        if len(needle) &gt; len(haystack) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt;= len(haystack)-len(needle); i++ </span><span class="cov0" title="0">{
                if haystack[i:i+len(needle)] == needle </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package views

import (
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// ConfirmView displays a confirmation dialog
type ConfirmView struct {
        title       string
        message     string
        confirmText string
        cancelText  string
        confirmed   bool
        width       int
        height      int
}

// NewConfirmView creates a new confirmation dialog
func NewConfirmView(title, message string) *ConfirmView <span class="cov0" title="0">{
        return &amp;ConfirmView{
                title:       title,
                message:     message,
                confirmText: "Yes",
                cancelText:  "No",
                confirmed:   false, // Default to No for safety
        }
}</span>

// Init initializes the view
func (v *ConfirmView) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles messages
func (v *ConfirmView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "left", "h", "tab":<span class="cov0" title="0">
                        v.confirmed = !v.confirmed</span>
                case "right", "l":<span class="cov0" title="0">
                        v.confirmed = !v.confirmed</span>
                case "y", "Y":<span class="cov0" title="0">
                        v.confirmed = true
                        return v, nil</span>
                case "n", "N":<span class="cov0" title="0">
                        v.confirmed = false
                        return v, nil</span>
                case "enter", " ":<span class="cov0" title="0">
                        // Action confirmed or cancelled - will be handled by parent
                        return v, nil</span>
                case "q":<span class="cov0" title="0">
                        // Cancel with q
                        v.confirmed = false
                        return v, nil</span>
                        // Don't handle ESC here - let parent handle it
                }
        }
        <span class="cov0" title="0">return v, nil</span>
}

// View renders the confirmation dialog
func (v *ConfirmView) View() string <span class="cov0" title="0">{
        // Create styles
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("1")). // Red for delete confirmation
                MarginBottom(1)

        messageStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("7")).
                MarginBottom(2)

        borderStyle := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("1")). // Red border for danger
                Padding(1, 2).
                Width(60).
                Height(10)

        selectedStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("0")).
                Background(lipgloss.Color("7")).
                Bold(true).
                Padding(0, 2)

        unselectedStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("7")).
                Padding(0, 2)

        // Build content
        var content strings.Builder

        // Title
        content.WriteString(titleStyle.Render(v.title))
        content.WriteString("\n\n")

        // Message
        content.WriteString(messageStyle.Render(v.message))
        content.WriteString("\n\n")

        // Buttons
        var yesButton, noButton string
        if v.confirmed </span><span class="cov0" title="0">{
                yesButton = selectedStyle.Render(v.confirmText)
                noButton = unselectedStyle.Render(v.cancelText)
        }</span> else<span class="cov0" title="0"> {
                yesButton = unselectedStyle.Render(v.confirmText)
                noButton = selectedStyle.Render(v.cancelText)
        }</span>

        <span class="cov0" title="0">buttons := lipgloss.JoinHorizontal(
                lipgloss.Center,
                noButton,
                "    ",
                yesButton,
        )

        // Center the buttons
        buttonsWidth := lipgloss.Width(buttons)
        contentWidth := 56 // borderStyle width minus padding
        padding := (contentWidth - buttonsWidth) / 2
        if padding &gt; 0 </span><span class="cov0" title="0">{
                buttons = strings.Repeat(" ", padding) + buttons
        }</span>

        <span class="cov0" title="0">content.WriteString(buttons)

        // Help text
        helpText := "\n\n[←→/Tab] Switch  [Y/N] Select  [Enter] Confirm  [Esc] Cancel"
        content.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(helpText))

        // Center the dialog
        return lipgloss.Place(
                v.width,
                v.height,
                lipgloss.Center,
                lipgloss.Center,
                borderStyle.Render(content.String()),
        )</span>
}

// SetSize updates the view size
func (v *ConfirmView) SetSize(width, height int) <span class="cov0" title="0">{
        v.width = width
        v.height = height
}</span>

// IsConfirmed returns whether the user confirmed the action
func (v *ConfirmView) IsConfirmed() bool <span class="cov0" title="0">{
        return v.confirmed
}</span>

// SetConfirmText sets custom confirm button text
func (v *ConfirmView) SetConfirmText(text string) <span class="cov0" title="0">{
        v.confirmText = text
}</span>

// SetCancelText sets custom cancel button text
func (v *ConfirmView) SetCancelText(text string) <span class="cov0" title="0">{
        v.cancelText = text
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package views

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// ContextView displays available Kubernetes contexts for selection
type ContextView struct {
        contexts         []string
        selectedContexts map[string]bool // For multi-select
        currentIndex     int
        width            int
        height           int
        searchQuery      string
        searchMode       bool
        multiSelect      bool // Toggle between single and multi-select mode
}

// NewContextView creates a new context selector view
func NewContextView(contexts []string, currentContexts []string) *ContextView <span class="cov0" title="0">{
        selectedMap := make(map[string]bool)
        for _, ctx := range currentContexts </span><span class="cov0" title="0">{
                selectedMap[ctx] = true
        }</span>

        <span class="cov0" title="0">return &amp;ContextView{
                contexts:         contexts,
                selectedContexts: selectedMap,
                currentIndex:     0,
                multiSelect:      len(currentContexts) &gt; 1,
        }</span>
}

// Init initializes the view
func (v *ContextView) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles messages
func (v *ContextView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                v.width = msg.Width
                v.height = msg.Height</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                if v.searchMode </span><span class="cov0" title="0">{
                        switch msg.String() </span>{
                        case "enter":<span class="cov0" title="0">
                                v.searchMode = false
                                v.filterContexts()
                                v.ensureValidIndex()</span>
                        case "esc":<span class="cov0" title="0">
                                v.searchMode = false
                                v.searchQuery = ""
                                v.ensureValidIndex()</span>
                        case "backspace":<span class="cov0" title="0">
                                if len(v.searchQuery) &gt; 0 </span><span class="cov0" title="0">{
                                        v.searchQuery = v.searchQuery[:len(v.searchQuery)-1]
                                        v.ensureValidIndex()
                                }</span>
                        default:<span class="cov0" title="0">
                                if len(msg.String()) == 1 </span><span class="cov0" title="0">{
                                        v.searchQuery += msg.String()
                                        v.ensureValidIndex()
                                }</span>
                        }
                        <span class="cov0" title="0">return v, nil</span>
                }

                <span class="cov0" title="0">switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if v.currentIndex &gt; 0 </span><span class="cov0" title="0">{
                                v.currentIndex--
                        }</span>
                        <span class="cov0" title="0">v.ensureValidIndex()</span>
                case "down", "j":<span class="cov0" title="0">
                        visibleContexts := v.getVisibleContexts()
                        if v.currentIndex &lt; len(visibleContexts)-1 </span><span class="cov0" title="0">{
                                v.currentIndex++
                        }</span>
                        <span class="cov0" title="0">v.ensureValidIndex()</span>
                case "space":<span class="cov0" title="0">
                        // Toggle selection for current context
                        visibleContexts := v.getVisibleContexts()
                        if v.currentIndex &lt; len(visibleContexts) </span><span class="cov0" title="0">{
                                ctx := visibleContexts[v.currentIndex]
                                if v.multiSelect </span><span class="cov0" title="0">{
                                        v.selectedContexts[ctx] = !v.selectedContexts[ctx]
                                }</span> else<span class="cov0" title="0"> {
                                        // Single select - clear others
                                        v.selectedContexts = make(map[string]bool)
                                        v.selectedContexts[ctx] = true
                                }</span>
                        }
                case "a":<span class="cov0" title="0">
                        // Select/deselect all (in multi-select mode)
                        if v.multiSelect </span><span class="cov0" title="0">{
                                allSelected := len(v.selectedContexts) == len(v.contexts)
                                v.selectedContexts = make(map[string]bool)
                                if !allSelected </span><span class="cov0" title="0">{
                                        for _, ctx := range v.contexts </span><span class="cov0" title="0">{
                                                v.selectedContexts[ctx] = true
                                        }</span>
                                }
                        }
                case "m":<span class="cov0" title="0">
                        // Toggle multi-select mode
                        v.multiSelect = !v.multiSelect
                        if !v.multiSelect &amp;&amp; len(v.selectedContexts) &gt; 1 </span><span class="cov0" title="0">{
                                // Keep only current selection in single mode
                                if v.currentIndex &lt; len(v.contexts) </span><span class="cov0" title="0">{
                                        ctx := v.contexts[v.currentIndex]
                                        v.selectedContexts = make(map[string]bool)
                                        v.selectedContexts[ctx] = true
                                }</span>
                        }
                case "/":<span class="cov0" title="0">
                        v.searchMode = true
                        v.searchQuery = ""</span>
                case "i":<span class="cov0" title="0">
                        // Show context info
                        visibleContexts := v.getVisibleContexts()
                        if v.currentIndex &lt; len(visibleContexts) </span><span class="cov0" title="0">{
                                ctx := visibleContexts[v.currentIndex]
                                return v, v.showContextInfo(ctx)
                        }</span>
                case "enter":<span class="cov0" title="0">
                        // Confirm selection
                        return v, nil</span>
                case "esc", "q":<span class="cov0" title="0">
                        // Cancel
                        return v, nil</span>
                }
        }
        <span class="cov0" title="0">return v, nil</span>
}

// View renders the context selector
func (v *ContextView) View() string <span class="cov0" title="0">{
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(1)

        title := "Select Kubernetes Context(s)"
        if v.multiSelect </span><span class="cov0" title="0">{
                title += " [Multi-Select Mode]"
        }</span>

        <span class="cov0" title="0">var content strings.Builder
        content.WriteString(titleStyle.Render(title))
        content.WriteString("\n\n")

        // Search or filter display
        if v.searchMode </span><span class="cov0" title="0">{
                searchStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("229"))
                content.WriteString(searchStyle.Render(fmt.Sprintf("Search: %s_", v.searchQuery)))
                content.WriteString("\n\n")
        }</span>

        // Context list
        <span class="cov0" title="0">itemStyle := lipgloss.NewStyle().PaddingLeft(2)
        selectedStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("86")).
                Bold(true)
        currentStyle := lipgloss.NewStyle().
                Background(lipgloss.Color("237"))

        visibleContexts := v.getVisibleContexts()
        maxVisible := v.height - 10 // Leave room for header and help
        startIdx := 0
        if v.currentIndex &gt;= maxVisible </span><span class="cov0" title="0">{
                startIdx = v.currentIndex - maxVisible + 1
        }</span>

        <span class="cov0" title="0">for i := startIdx; i &lt; len(visibleContexts) &amp;&amp; i &lt; startIdx+maxVisible; i++ </span><span class="cov0" title="0">{
                ctx := visibleContexts[i]
                line := ""

                // Selection indicator
                if v.selectedContexts[ctx] </span><span class="cov0" title="0">{
                        line = "[✓] "
                }</span> else<span class="cov0" title="0"> {
                        line = "[ ] "
                }</span>
                <span class="cov0" title="0">line += ctx

                // Apply styles
                if v.selectedContexts[ctx] </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>
                // Fix: compare with the relative index in the visible list
                <span class="cov0" title="0">if i == v.currentIndex </span><span class="cov0" title="0">{
                        line = currentStyle.Render(line)
                }</span>

                <span class="cov0" title="0">content.WriteString(itemStyle.Render(line))
                content.WriteString("\n")</span>
        }

        // Help text
        <span class="cov0" title="0">helpStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                MarginTop(2)

        helpText := "↑↓: Navigate | Space: Toggle | Enter: Confirm | i: Info | Esc: Cancel"
        if v.multiSelect </span><span class="cov0" title="0">{
                helpText += " | a: All | m: Single mode"
        }</span> else<span class="cov0" title="0"> {
                helpText += " | m: Multi mode"
        }</span>
        <span class="cov0" title="0">helpText += " | /: Search"

        content.WriteString(helpStyle.Render(helpText))

        // Center in window
        return lipgloss.Place(
                v.width,
                v.height,
                lipgloss.Center,
                lipgloss.Center,
                content.String(),
        )</span>
}

// GetSelectedContexts returns the selected context names
func (v *ContextView) GetSelectedContexts() []string <span class="cov0" title="0">{
        var selected []string
        for ctx, isSelected := range v.selectedContexts </span><span class="cov0" title="0">{
                if isSelected </span><span class="cov0" title="0">{
                        selected = append(selected, ctx)
                }</span>
        }
        <span class="cov0" title="0">return selected</span>
}

// filterContexts filters the context list based on search query
func (v *ContextView) filterContexts() <span class="cov0" title="0">{
        // Reset current index to ensure it's valid for filtered results
        v.currentIndex = 0
}</span>

// getVisibleContexts returns contexts that match the search filter
func (v *ContextView) getVisibleContexts() []string <span class="cov0" title="0">{
        if v.searchQuery == "" </span><span class="cov0" title="0">{
                return v.contexts
        }</span>

        <span class="cov0" title="0">var filtered []string
        query := strings.ToLower(v.searchQuery)
        for _, ctx := range v.contexts </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(ctx), query) </span><span class="cov0" title="0">{
                        filtered = append(filtered, ctx)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// SetSize updates the view size
func (v *ContextView) SetSize(width, height int) <span class="cov0" title="0">{
        v.width = width
        v.height = height
}</span>

// showContextInfo shows detailed information about a context
func (v *ContextView) showContextInfo(contextName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return ContextInfoMsg{ContextName: contextName}
        }</span>
}

// ContextInfoMsg is sent when context info should be displayed
type ContextInfoMsg struct {
        ContextName string
}

// ensureValidIndex ensures currentIndex is within bounds of visible contexts
func (v *ContextView) ensureValidIndex() <span class="cov0" title="0">{
        visibleContexts := v.getVisibleContexts()
        if len(visibleContexts) == 0 </span><span class="cov0" title="0">{
                v.currentIndex = 0
                return
        }</span>
        <span class="cov0" title="0">if v.currentIndex &gt;= len(visibleContexts) </span><span class="cov0" title="0">{
                v.currentIndex = len(visibleContexts) - 1
        }</span>
        <span class="cov0" title="0">if v.currentIndex &lt; 0 </span><span class="cov0" title="0">{
                v.currentIndex = 0
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package views

import (
        "encoding/base64"
        "fmt"
        "sort"
        "strings"

        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        v1 "k8s.io/api/core/v1"
)

// DataView displays ConfigMap or Secret data
type DataView struct {
        viewport     viewport.Model
        resourceType string // "ConfigMap" or "Secret"
        resourceName string
        namespace    string
        data         map[string]string
        binaryData   map[string][]byte
        decoded      bool // For secrets, toggle between encoded/decoded
        selectedKey  int
        keys         []string
        width        int
        height       int
        ready        bool
}

// NewConfigMapView creates a view for a ConfigMap
func NewConfigMapView(cm *v1.ConfigMap) *DataView <span class="cov0" title="0">{
        v := &amp;DataView{
                viewport:     viewport.New(80, 20),
                resourceType: "ConfigMap",
                resourceName: cm.Name,
                namespace:    cm.Namespace,
                data:         cm.Data,
                binaryData:   cm.BinaryData,
                decoded:      true, // ConfigMaps are always decoded
        }
        v.updateKeys()
        return v
}</span>

// NewSecretView creates a view for a Secret
func NewSecretView(secret *v1.Secret) *DataView <span class="cov0" title="0">{
        // Convert byte data to strings for display
        data := make(map[string]string)
        for k, v := range secret.Data </span><span class="cov0" title="0">{
                data[k] = string(v)
        }</span>

        <span class="cov0" title="0">v := &amp;DataView{
                viewport:     viewport.New(80, 20),
                resourceType: "Secret",
                resourceName: secret.Name,
                namespace:    secret.Namespace,
                data:         data,
                decoded:      false, // Secrets start encoded
        }
        v.updateKeys()
        return v</span>
}

// Init initializes the view
func (v *DataView) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles messages
func (v *DataView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                v.width = msg.Width
                v.height = msg.Height
                if !v.ready </span><span class="cov0" title="0">{
                        v.viewport = viewport.New(msg.Width, msg.Height-4) // Leave room for header and footer
                        v.viewport.YPosition = 0
                        v.ready = true
                }</span> else<span class="cov0" title="0"> {
                        v.viewport.Width = msg.Width
                        v.viewport.Height = msg.Height - 4
                }</span>
                <span class="cov0" title="0">v.updateContent()</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "d":<span class="cov0" title="0">
                        // Toggle decode for secrets
                        if v.resourceType == "Secret" </span><span class="cov0" title="0">{
                                v.decoded = !v.decoded
                                v.updateContent()
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                case "tab", "j":<span class="cov0" title="0">
                        // Next key
                        if v.selectedKey &lt; len(v.keys)-1 </span><span class="cov0" title="0">{
                                v.selectedKey++
                                v.updateContent()
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                case "shift+tab", "k":<span class="cov0" title="0">
                        // Previous key
                        if v.selectedKey &gt; 0 </span><span class="cov0" title="0">{
                                v.selectedKey--
                                v.updateContent()
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                case "g", "home":<span class="cov0" title="0">
                        v.viewport.GotoTop()
                        return v, nil</span>
                case "G", "end":<span class="cov0" title="0">
                        v.viewport.GotoBottom()
                        return v, nil</span>
                case "esc", "q":<span class="cov0" title="0">
                        // Close view
                        return v, nil</span>
                }
        }

        <span class="cov0" title="0">v.viewport, cmd = v.viewport.Update(msg)
        return v, cmd</span>
}

// View renders the data view
func (v *DataView) View() string <span class="cov0" title="0">{
        if !v.ready </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>

        // Header
        <span class="cov0" title="0">headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86"))

        header := fmt.Sprintf("📦 %s: %s/%s", v.resourceType, v.namespace, v.resourceName)
        if v.resourceType == "Secret" </span><span class="cov0" title="0">{
                if v.decoded </span><span class="cov0" title="0">{
                        header += " [DECODED]"
                }</span> else<span class="cov0" title="0"> {
                        header += " [ENCODED]"
                }</span>
        }

        // Footer with controls
        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        footer := "Tab/j/k: Navigate keys | ↑↓: Scroll | g/G: Top/Bottom"
        if v.resourceType == "Secret" </span><span class="cov0" title="0">{
                footer += " | d: Toggle decode"
        }</span>
        <span class="cov0" title="0">footer += " | Esc: Close"

        // Key list
        keyListStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("229")).
                Bold(true)

        keyInfo := ""
        if len(v.keys) &gt; 0 </span><span class="cov0" title="0">{
                keyInfo = fmt.Sprintf(" | Key %d/%d: %s", v.selectedKey+1, len(v.keys), v.keys[v.selectedKey])
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "%s%s\n%s\n%s",
                headerStyle.Render(header),
                keyListStyle.Render(keyInfo),
                v.viewport.View(),
                footerStyle.Render(footer),
        )</span>
}

// updateKeys updates the sorted list of keys
func (v *DataView) updateKeys() <span class="cov0" title="0">{
        v.keys = []string{}

        // Add regular data keys
        for k := range v.data </span><span class="cov0" title="0">{
                v.keys = append(v.keys, k)
        }</span>

        // Add binary data keys
        <span class="cov0" title="0">for k := range v.binaryData </span><span class="cov0" title="0">{
                v.keys = append(v.keys, k+" (binary)")
        }</span>

        <span class="cov0" title="0">sort.Strings(v.keys)

        if v.selectedKey &gt;= len(v.keys) &amp;&amp; len(v.keys) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedKey = len(v.keys) - 1
        }</span>
}

// updateContent updates the viewport content based on selected key
func (v *DataView) updateContent() <span class="cov0" title="0">{
        if len(v.keys) == 0 </span><span class="cov0" title="0">{
                v.viewport.SetContent("No data")
                return
        }</span>

        <span class="cov0" title="0">if v.selectedKey &gt;= len(v.keys) </span><span class="cov0" title="0">{
                v.selectedKey = len(v.keys) - 1
        }</span>

        <span class="cov0" title="0">key := v.keys[v.selectedKey]
        isBinary := strings.HasSuffix(key, " (binary)")
        if isBinary </span><span class="cov0" title="0">{
                key = strings.TrimSuffix(key, " (binary)")
        }</span>

        <span class="cov0" title="0">var content string

        // Style for the content
        contentStyle := lipgloss.NewStyle().
                Padding(1, 2)

        keyStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("86")).
                Bold(true)

        // Build content for all keys or selected key
        if v.selectedKey &lt; 0 </span><span class="cov0" title="0">{
                // Show all keys (overview mode)
                var lines []string
                for _, k := range v.keys </span><span class="cov0" title="0">{
                        lines = append(lines, keyStyle.Render(k))
                }</span>
                <span class="cov0" title="0">content = strings.Join(lines, "\n")</span>
        } else<span class="cov0" title="0"> {
                // Show selected key's value
                content = keyStyle.Render(fmt.Sprintf("Key: %s", key)) + "\n\n"

                if isBinary </span><span class="cov0" title="0">{
                        // Binary data
                        if data, ok := v.binaryData[key]; ok </span><span class="cov0" title="0">{
                                if v.decoded &amp;&amp; v.resourceType == "Secret" </span><span class="cov0" title="0">{
                                        // Try to decode and display as string
                                        content += string(data)
                                }</span> else<span class="cov0" title="0"> {
                                        // Show as base64
                                        content += base64.StdEncoding.EncodeToString(data)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Regular string data
                        if value, ok := v.data[key]; ok </span><span class="cov0" title="0">{
                                if v.resourceType == "Secret" &amp;&amp; !v.decoded </span><span class="cov0" title="0">{
                                        // Show encoded (base64)
                                        content += base64.StdEncoding.EncodeToString([]byte(value))
                                }</span> else<span class="cov0" title="0"> if v.resourceType == "Secret" &amp;&amp; v.decoded </span><span class="cov0" title="0">{
                                        // Decode from base64
                                        decoded, err := base64.StdEncoding.DecodeString(value)
                                        if err != nil </span><span class="cov0" title="0">{
                                                content += fmt.Sprintf("Error decoding: %v\n\nRaw value:\n%s", err, value)
                                        }</span> else<span class="cov0" title="0"> {
                                                content += string(decoded)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // ConfigMap - show as is
                                        content += value
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">v.viewport.SetContent(contentStyle.Render(content))</span>
}

// SetSize updates the view size
func (v *DataView) SetSize(width, height int) <span class="cov0" title="0">{
        v.width = width
        v.height = height
        v.viewport.Width = width
        v.viewport.Height = height - 4
        v.ready = true
        v.updateContent()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package views

import (
        "bytes"
        "context"
        "fmt"
        "strings"

        "github.com/HamStudy/kubewatch/internal/k8s"
        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// DescribeView displays the kubectl describe output for a resource
type DescribeView struct {
        viewport     viewport.Model
        content      string
        resourceType string
        resourceName string
        namespace    string
        context      string
        width        int
        height       int
        ready        bool
        loading      bool
}

// NewDescribeView creates a new describe view for a resource
func NewDescribeView(resourceType, resourceName, namespace, context string) *DescribeView <span class="cov0" title="0">{
        return &amp;DescribeView{
                viewport:     viewport.New(80, 20),
                resourceType: resourceType,
                resourceName: resourceName,
                namespace:    namespace,
                context:      context,
                loading:      true,
        }
}</span>

// Init initializes the view
func (v *DescribeView) Init() tea.Cmd <span class="cov0" title="0">{
        return v.loadDescribe()
}</span>

// loadDescribe loads the describe output for the resource
func (v *DescribeView) loadDescribe() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Use placeholder content for now - real implementation would need client access
                return describeLoadedMsg{
                        content: v.getDescribeContent(),
                }
        }</span>
}

// LoadDescribeWithClient loads the describe output using a real K8s client
func (v *DescribeView) LoadDescribeWithClient(ctx context.Context, client *k8s.Client) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                content, err := GetDescribeContent(ctx, client, v.resourceType, v.resourceName, v.namespace)
                return describeLoadedMsg{
                        content: content,
                        err:     err,
                }
        }</span>
}

// getDescribeContent gets the describe content using the K8s client
func (v *DescribeView) getDescribeContent() string <span class="cov0" title="0">{
        // In a real implementation, this would use the K8s client to get detailed resource info
        // For now, return formatted placeholder content
        var buf bytes.Buffer

        buf.WriteString(fmt.Sprintf("Name:         %s\n", v.resourceName))
        buf.WriteString(fmt.Sprintf("Namespace:    %s\n", v.namespace))
        if v.context != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("Context:      %s\n", v.context))
        }</span>
        <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("Type:         %s\n", v.resourceType))
        buf.WriteString("\n")

        // Add type-specific information
        switch v.resourceType </span>{
        case "Pod":<span class="cov0" title="0">
                buf.WriteString("Status:       Running\n")
                buf.WriteString("IP:           10.244.1.5\n")
                buf.WriteString("Node:         node-1\n")
                buf.WriteString("\nContainers:\n")
                buf.WriteString("  app:\n")
                buf.WriteString("    Image:      nginx:latest\n")
                buf.WriteString("    Port:       80/TCP\n")
                buf.WriteString("    State:      Running\n")
                buf.WriteString("    Ready:      True\n")
                buf.WriteString("    Restart Count: 0\n")</span>

        case "Deployment":<span class="cov0" title="0">
                buf.WriteString("Replicas:     3 desired | 3 updated | 3 total | 3 available\n")
                buf.WriteString("Strategy:     RollingUpdate\n")
                buf.WriteString("Selector:     app=nginx\n")
                buf.WriteString("\nPod Template:\n")
                buf.WriteString("  Labels:     app=nginx\n")
                buf.WriteString("  Containers:\n")
                buf.WriteString("    nginx:\n")
                buf.WriteString("      Image:    nginx:latest\n")
                buf.WriteString("      Port:     80/TCP\n")</span>

        case "Service":<span class="cov0" title="0">
                buf.WriteString("Type:         ClusterIP\n")
                buf.WriteString("IP:           10.96.1.1\n")
                buf.WriteString("Port:         http 80/TCP\n")
                buf.WriteString("Endpoints:    10.244.1.5:80,10.244.1.6:80\n")</span>

        default:<span class="cov0" title="0">
                buf.WriteString("(Detailed information would appear here)\n")</span>
        }

        <span class="cov0" title="0">buf.WriteString("\nEvents:\n")
        buf.WriteString("  Type    Reason    Age   From               Message\n")
        buf.WriteString("  ----    ------    ----  ----               -------\n")
        buf.WriteString("  Normal  Scheduled 5m    default-scheduler  Successfully assigned to node-1\n")
        buf.WriteString("  Normal  Pulled    5m    kubelet            Container image already present\n")
        buf.WriteString("  Normal  Created   5m    kubelet            Created container\n")
        buf.WriteString("  Normal  Started   5m    kubelet            Started container\n")

        return buf.String()</span>
}

// GetDescribeUsingClient gets actual describe content using the K8s client
func GetDescribeContent(ctx context.Context, client *k8s.Client, resourceType, resourceName, namespace string) (string, error) <span class="cov0" title="0">{
        return client.DescribeResource(ctx, resourceType, resourceName, namespace)
}</span>

// Update handles messages
func (v *DescribeView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                v.width = msg.Width
                v.height = msg.Height
                if !v.ready </span><span class="cov0" title="0">{
                        v.viewport = viewport.New(msg.Width, msg.Height-3) // Leave room for header and footer
                        v.viewport.YPosition = 0
                        v.ready = true
                }</span> else<span class="cov0" title="0"> {
                        v.viewport.Width = msg.Width
                        v.viewport.Height = msg.Height - 3
                }</span>
                <span class="cov0" title="0">if v.content != "" </span><span class="cov0" title="0">{
                        v.viewport.SetContent(v.content)
                }</span>

        case describeLoadedMsg:<span class="cov0" title="0">
                v.loading = false
                if msg.err != nil </span><span class="cov0" title="0">{
                        v.content = fmt.Sprintf("Error loading description: %v", msg.err)
                }</span> else<span class="cov0" title="0"> {
                        v.content = msg.content
                }</span>
                <span class="cov0" title="0">v.viewport.SetContent(v.content)
                return v, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "g", "home":<span class="cov0" title="0">
                        v.viewport.GotoTop()
                        return v, nil</span>
                case "G", "end":<span class="cov0" title="0">
                        v.viewport.GotoBottom()
                        return v, nil</span>
                case "esc", "q":<span class="cov0" title="0">
                        // Close view
                        return v, nil</span>
                }
        }

        <span class="cov0" title="0">v.viewport, cmd = v.viewport.Update(msg)
        return v, cmd</span>
}

// View renders the describe view
func (v *DescribeView) View() string <span class="cov0" title="0">{
        if !v.ready </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>

        // Header
        <span class="cov0" title="0">headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86"))

        resourceInfo := fmt.Sprintf("%s/%s", v.resourceType, v.resourceName)
        if v.namespace != "" </span><span class="cov0" title="0">{
                resourceInfo = fmt.Sprintf("%s/%s", v.namespace, resourceInfo)
        }</span>
        <span class="cov0" title="0">if v.context != "" </span><span class="cov0" title="0">{
                resourceInfo = fmt.Sprintf("[%s] %s", v.context, resourceInfo)
        }</span>

        <span class="cov0" title="0">header := fmt.Sprintf("📋 Describe: %s", resourceInfo)

        // Footer with controls
        footerStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        footer := "↑↓/PgUp/PgDn: Scroll | g/G: Top/Bottom | Esc: Close"

        // Loading indicator
        if v.loading </span><span class="cov0" title="0">{
                loadingStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("229"))
                return fmt.Sprintf(
                        "%s\n%s\n%s",
                        headerStyle.Render(header),
                        loadingStyle.Render("Loading describe information..."),
                        footerStyle.Render(footer),
                )
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "%s\n%s\n%s",
                headerStyle.Render(header),
                v.viewport.View(),
                footerStyle.Render(footer),
        )</span>
}

// SetSize updates the view size
func (v *DescribeView) SetSize(width, height int) <span class="cov0" title="0">{
        v.width = width
        v.height = height
        v.viewport.Width = width
        v.viewport.Height = height - 3
        v.ready = true
}</span>

// describeLoadedMsg is sent when describe content is loaded
type describeLoadedMsg struct {
        content string
        err     error
}

// FormatResourceType formats the resource type for display
func FormatResourceType(resourceType string) string <span class="cov0" title="0">{
        // Remove trailing 's' for singular form
        if strings.HasSuffix(resourceType, "s") &amp;&amp; resourceType != "ingress" </span><span class="cov0" title="0">{
                return resourceType[:len(resourceType)-1]
        }</span>
        <span class="cov0" title="0">return resourceType</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package views

import (
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// HelpView displays help information
type HelpView struct {
        width       int
        height      int
        contextMode string // "resource" or "logs"
}

// NewHelpView creates a new help view
func NewHelpView() *HelpView <span class="cov0" title="0">{
        return &amp;HelpView{
                contextMode: "resource",
        }
}</span>

// SetContext sets the help context (resource or logs)
func (v *HelpView) SetContext(context string) <span class="cov0" title="0">{
        v.contextMode = context
}</span>

// SetModeHelp sets help content from a screen mode
func (v *HelpView) SetModeHelp(mode interface{}) {<span class="cov0" title="0">
        // This will be used to auto-generate help from mode key bindings
        // For now, we'll keep the existing manual help
}</span>

// Init initializes the view
func (v *HelpView) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles messages
func (v *HelpView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                v.width = msg.Width
                v.height = msg.Height</span>
        }
        <span class="cov0" title="0">return v, nil</span>
}

// View renders the help screen
func (v *HelpView) View() string <span class="cov0" title="0">{
        if v.contextMode == "logs" </span><span class="cov0" title="0">{
                return v.renderLogHelp()
        }</span>
        <span class="cov0" title="0">return v.renderResourceHelp()</span>
}

// renderResourceHelp renders help for resource view
func (v *HelpView) renderResourceHelp() string <span class="cov0" title="0">{
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        sectionStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("212")).
                MarginTop(1).
                MarginBottom(1)

        keyStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("229")).
                Bold(true)

        descStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("241"))

        var help strings.Builder

        help.WriteString(titleStyle.Render("KubeWatch TUI - Resource View Help"))
        help.WriteString("\n\n")

        help.WriteString(sectionStyle.Render("Navigation"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("↑/k") + descStyle.Render("    Move up") + "\n")
        help.WriteString(keyStyle.Render("↓/j") + descStyle.Render("    Move down") + "\n")
        help.WriteString(keyStyle.Render("Tab") + descStyle.Render("    Next resource type") + "\n")
        help.WriteString(keyStyle.Render("S-Tab") + descStyle.Render("  Previous resource type") + "\n")
        help.WriteString(keyStyle.Render("n") + descStyle.Render("      Change namespace") + "\n")
        help.WriteString(keyStyle.Render("c") + descStyle.Render("      Switch contexts (multi-context mode)") + "\n")

        help.WriteString(sectionStyle.Render("Actions"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("Enter/l") + descStyle.Render(" View logs") + "\n")
        help.WriteString(keyStyle.Render("Del/D") + descStyle.Render("   Delete selected") + "\n")
        help.WriteString(keyStyle.Render("r") + descStyle.Render("       Manual refresh") + "\n")
        help.WriteString(keyStyle.Render("s") + descStyle.Render("       Cycle sort column/direction") + "\n")
        help.WriteString(keyStyle.Render("u") + descStyle.Render("       Toggle word wrap") + "\n")

        help.WriteString(sectionStyle.Render("General"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("?") + descStyle.Render("      Toggle help") + "\n")
        help.WriteString(keyStyle.Render("q") + descStyle.Render("      Quit") + "\n")
        help.WriteString(keyStyle.Render("Esc") + descStyle.Render("    Close dialog") + "\n")

        help.WriteString("\n\n")
        help.WriteString(descStyle.Render("Press ? to close help"))

        return lipgloss.Place(
                v.width,
                v.height,
                lipgloss.Center,
                lipgloss.Center,
                help.String(),
        )
}</span>

// renderLogHelp renders help for log view
func (v *HelpView) renderLogHelp() string <span class="cov0" title="0">{
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        sectionStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("212")).
                MarginTop(1).
                MarginBottom(1)

        keyStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("229")).
                Bold(true)

        descStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("241"))

        var help strings.Builder

        help.WriteString(titleStyle.Render("KubeWatch TUI - Log View Help"))
        help.WriteString("\n\n")

        help.WriteString(sectionStyle.Render("Navigation"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("↑/k") + descStyle.Render("    Scroll up") + "\n")
        help.WriteString(keyStyle.Render("↓/j") + descStyle.Render("    Scroll down") + "\n")
        help.WriteString(keyStyle.Render("PgUp") + descStyle.Render("   Page up") + "\n")
        help.WriteString(keyStyle.Render("PgDn") + descStyle.Render("   Page down") + "\n")
        help.WriteString(keyStyle.Render("Home/g") + descStyle.Render(" Jump to top") + "\n")
        help.WriteString(keyStyle.Render("End/G") + descStyle.Render("  Jump to bottom (follow)") + "\n")

        help.WriteString(sectionStyle.Render("Log Controls"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("f") + descStyle.Render("      Toggle follow mode") + "\n")
        help.WriteString(keyStyle.Render("/") + descStyle.Render("      Search in logs") + "\n")
        help.WriteString(keyStyle.Render("c") + descStyle.Render("      Cycle containers (all/individual)") + "\n")
        help.WriteString(keyStyle.Render("p") + descStyle.Render("      Cycle pods (for deployments)") + "\n")
        help.WriteString(keyStyle.Render("C") + descStyle.Render("      Clear log buffer") + "\n")

        help.WriteString(sectionStyle.Render("General"))
        help.WriteString("\n")
        help.WriteString(keyStyle.Render("Esc/q") + descStyle.Render("  Close logs") + "\n")
        help.WriteString(keyStyle.Render("?") + descStyle.Render("      Toggle help") + "\n")

        help.WriteString("\n\n")
        help.WriteString(descStyle.Render("Press ? to close help"))

        return lipgloss.Place(
                v.width,
                v.height,
                lipgloss.Center,
                lipgloss.Center,
                help.String(),
        )
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package views

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/HamStudy/kubewatch/internal/core"
        "github.com/HamStudy/kubewatch/internal/k8s"
        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        v1 "k8s.io/api/core/v1"
)

// LogView displays logs from pods
type LogView struct {
        viewport viewport.Model
        content  []string
        width    int
        height   int
        ready    bool

        // Log streaming
        ctx        context.Context
        cancelFunc context.CancelFunc
        logReaders []io.ReadCloser  // Multiple readers for multiple containers
        scanners   []*bufio.Scanner // Multiple scanners
        containers []string         // Container names
        following  bool             // Auto-scroll to bottom
        tailing    bool             // Keep reading new logs (always true while streaming)

        // Search functionality
        searchMode    bool
        searchQuery   string
        searchResults []int // Line indices that match search
        currentMatch  int   // Current match index

        // Stream control
        showStdout        bool
        showStderr        bool
        selectedContainer int // -1 for all, 0+ for specific container

        // For deployments
        pods        []string
        selectedPod int // -1 for all, 0+ for specific pod

        // For restarting streams
        client       *k8s.Client
        state        *core.State
        resourceName string
        needsRestart bool
}

// NewLogView creates a new log view
func NewLogView() *LogView <span class="cov8" title="1">{
        return &amp;LogView{
                viewport:          viewport.New(80, 20),
                content:           []string{},
                showStdout:        true,
                showStderr:        true,
                selectedContainer: -1, // Show all containers by default
                selectedPod:       -1, // Show all pods by default
                searchResults:     []int{},
        }
}</span>

// IsSearchMode returns true if the log view is in search mode
func (v *LogView) IsSearchMode() bool <span class="cov8" title="1">{
        return v.searchMode
}</span>

// Init initializes the view
func (v *LogView) Init() tea.Cmd <span class="cov8" title="1">{
        return nil
}</span>

// Update handles messages
func (v *LogView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                // Handle search mode input
                if v.searchMode </span><span class="cov8" title="1">{
                        switch msg.String() </span>{
                        case "enter":<span class="cov0" title="0">
                                v.searchMode = false
                                v.performSearch()
                                return v, nil</span>
                        case "esc":<span class="cov8" title="1">
                                // Cancel search mode
                                v.searchMode = false
                                v.searchQuery = ""
                                v.searchResults = []int{}
                                return v, nil</span>
                        case "backspace":<span class="cov0" title="0">
                                if len(v.searchQuery) &gt; 0 </span><span class="cov0" title="0">{
                                        v.searchQuery = v.searchQuery[:len(v.searchQuery)-1]
                                }</span>
                                <span class="cov0" title="0">return v, nil</span>
                        default:<span class="cov8" title="1">
                                if len(msg.String()) == 1 </span><span class="cov8" title="1">{
                                        v.searchQuery += msg.String()
                                }</span>
                                <span class="cov8" title="1">return v, nil</span>
                        }
                }

                // In normal mode, don't handle ESC - let the app handle it
                <span class="cov8" title="1">if msg.String() == "esc" </span><span class="cov0" title="0">{
                        // Let the parent app handle ESC to close the log view
                        return v, nil
                }</span>

                // Normal mode key handling
                <span class="cov8" title="1">switch msg.String() </span>{
                case "/":<span class="cov8" title="1">
                        // Start search mode
                        v.searchMode = true
                        v.searchQuery = ""
                        return v, nil</span>
                case "n":<span class="cov0" title="0">
                        // Next search result
                        if len(v.searchResults) &gt; 0 </span><span class="cov0" title="0">{
                                v.currentMatch = (v.currentMatch + 1) % len(v.searchResults)
                                v.jumpToMatch()
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                case "N":<span class="cov0" title="0">
                        // Previous search result
                        if len(v.searchResults) &gt; 0 </span><span class="cov0" title="0">{
                                v.currentMatch--
                                if v.currentMatch &lt; 0 </span><span class="cov0" title="0">{
                                        v.currentMatch = len(v.searchResults) - 1
                                }</span>
                                <span class="cov0" title="0">v.jumpToMatch()</span>
                        }
                        <span class="cov0" title="0">return v, nil</span>
                case "f":<span class="cov8" title="1">
                        // Toggle follow mode
                        v.following = !v.following
                        if v.following </span><span class="cov8" title="1">{
                                v.viewport.GotoBottom()
                        }</span>
                        <span class="cov8" title="1">return v, nil</span>
                case "c":<span class="cov8" title="1">
                        // Cycle through containers
                        if len(v.containers) &gt; 1 </span><span class="cov8" title="1">{
                                v.selectedContainer++
                                if v.selectedContainer &gt;= len(v.containers) </span><span class="cov8" title="1">{
                                        v.selectedContainer = -1 // Back to all
                                }</span>
                                // Restart streaming with selected container
                                <span class="cov8" title="1">return v, v.restartStreaming()</span>
                        }
                        <span class="cov0" title="0">return v, nil</span>
                case "p":<span class="cov8" title="1">
                        // Cycle through pods (for deployments)
                        if len(v.pods) &gt; 1 </span><span class="cov8" title="1">{
                                v.selectedPod++
                                if v.selectedPod &gt;= len(v.pods) </span><span class="cov8" title="1">{
                                        v.selectedPod = -1 // Back to all
                                }</span>
                                // Restart streaming with selected pod
                                <span class="cov8" title="1">return v, v.restartStreaming()</span>
                        }
                        <span class="cov0" title="0">return v, nil</span>
                case "s":<span class="cov0" title="0">
                        // Toggle stdout/stderr (Note: K8s API doesn't separate these streams)
                        // This is kept for future implementation if we add log parsing
                        if v.showStdout &amp;&amp; v.showStderr </span><span class="cov0" title="0">{
                                v.showStdout = true
                                v.showStderr = false
                        }</span> else<span class="cov0" title="0"> if v.showStdout &amp;&amp; !v.showStderr </span><span class="cov0" title="0">{
                                v.showStdout = false
                                v.showStderr = true
                        }</span> else<span class="cov0" title="0"> {
                                v.showStdout = true
                                v.showStderr = true
                        }</span>
                        // Note: Kubernetes API combines stdout/stderr, so this doesn't actually filter
                        // Would need to implement log parsing to detect stderr prefixes
                        <span class="cov0" title="0">v.content = append(v.content, "Note: Kubernetes combines stdout/stderr streams - filtering not available")
                        return v, nil</span>
                case "C":<span class="cov8" title="1">
                        // Clear log buffer
                        v.content = []string{}
                        v.viewport.SetContent("")
                        return v, nil</span>
                case "g", "home":<span class="cov8" title="1">
                        v.following = false
                        v.viewport.GotoTop()
                        return v, nil</span>
                case "G", "end":<span class="cov8" title="1">
                        v.following = true
                        v.viewport.GotoBottom()
                        return v, nil</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                v.width = msg.Width
                v.height = msg.Height
                if !v.ready </span><span class="cov0" title="0">{
                        v.viewport = viewport.New(msg.Width, msg.Height-3) // Extra line for status
                        v.viewport.YPosition = 0
                        v.ready = true
                }</span> else<span class="cov0" title="0"> {
                        v.viewport.Width = msg.Width
                        v.viewport.Height = msg.Height - 3
                }</span>

        case logStreamStartedMsg:<span class="cov0" title="0">
                // Stream has been initialized, start reading from all containers
                var cmds []tea.Cmd
                for i := range v.scanners </span><span class="cov0" title="0">{
                        cmds = append(cmds, v.readNextLine(i))
                }</span>
                <span class="cov0" title="0">return v, tea.Batch(cmds...)</span>

        case logLineMsg:<span class="cov0" title="0">
                // Format line with container prefix if multiple containers
                line := msg.line
                if len(v.containers) &gt; 1 </span><span class="cov0" title="0">{
                        line = fmt.Sprintf("[%s] %s", msg.container, msg.line)
                }</span>
                <span class="cov0" title="0">v.content = append(v.content, line)
                if len(v.content) &gt; 10000 </span><span class="cov0" title="0">{
                        // Keep last 10000 lines
                        v.content = v.content[len(v.content)-10000:]
                }</span>
                <span class="cov0" title="0">v.viewport.SetContent(strings.Join(v.content, "\n"))
                if v.following </span><span class="cov0" title="0">{
                        v.viewport.GotoBottom()
                }</span>
                // Continue reading from the container that sent this message
                <span class="cov0" title="0">for i, container := range v.containers </span><span class="cov0" title="0">{
                        if container == msg.container </span><span class="cov0" title="0">{
                                return v, v.readNextLine(i)
                        }</span>
                }
                <span class="cov0" title="0">return v, nil</span>

        case errMsg:<span class="cov0" title="0">
                // Display error in the log view
                v.content = append(v.content, fmt.Sprintf("Error: %v", msg.err))
                v.viewport.SetContent(strings.Join(v.content, "\n"))
                return v, nil</span>
        }

        // Check if user scrolled manually (disable auto-follow)
        <span class="cov8" title="1">oldY := v.viewport.YOffset
        v.viewport, cmd = v.viewport.Update(msg)
        if oldY != v.viewport.YOffset &amp;&amp; v.viewport.YOffset &lt; v.viewport.TotalLineCount()-v.viewport.Height </span><span class="cov0" title="0">{
                v.following = false
        }</span>

        <span class="cov8" title="1">return v, cmd</span>
}

// View renders the view
func (v *LogView) View() string <span class="cov8" title="1">{
        if !v.ready </span><span class="cov0" title="0">{
                return "Loading logs..."
        }</span>

        // Build header with status
        <span class="cov8" title="1">followStatus := "FOLLOWING"
        if !v.following </span><span class="cov8" title="1">{
                followStatus = "SCROLLING"
        }</span>

        // Container/Pod info
        <span class="cov8" title="1">streamInfo := ""
        if v.selectedContainer &gt;= 0 &amp;&amp; v.selectedContainer &lt; len(v.containers) </span><span class="cov0" title="0">{
                streamInfo = fmt.Sprintf(" | Container: %s", v.containers[v.selectedContainer])
        }</span> else<span class="cov8" title="1"> if len(v.containers) &gt; 1 </span><span class="cov0" title="0">{
                streamInfo = fmt.Sprintf(" | All %d containers", len(v.containers))
        }</span>

        <span class="cov8" title="1">if v.selectedPod &gt;= 0 &amp;&amp; v.selectedPod &lt; len(v.pods) </span><span class="cov0" title="0">{
                streamInfo += fmt.Sprintf(" | Pod: %s", v.pods[v.selectedPod])
        }</span> else<span class="cov8" title="1"> if len(v.pods) &gt; 1 </span><span class="cov0" title="0">{
                streamInfo += fmt.Sprintf(" | All %d pods", len(v.pods))
        }</span>

        <span class="cov8" title="1">header := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Render(fmt.Sprintf("📜 Logs [%s]%s", followStatus, streamInfo))
        // Build status line
        statusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

        statusText := ""
        if v.searchMode </span><span class="cov0" title="0">{
                // Show search input
                searchStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("229"))
                statusText = searchStyle.Render(fmt.Sprintf("Search: %s_", v.searchQuery))
        }</span> else<span class="cov8" title="1"> if len(v.searchResults) &gt; 0 </span><span class="cov0" title="0">{
                // Show search results
                statusText = fmt.Sprintf("Match %d/%d | n: next | N: prev | /: new search",
                        v.currentMatch+1, len(v.searchResults))
        }</span> else<span class="cov8" title="1"> {
                // Normal status
                statusText = fmt.Sprintf(
                        "Lines: %d | Pos: %d/%d | /: search | c: containers | p: pods | f: follow | ?: help",
                        len(v.content),
                        v.viewport.YOffset+1,
                        v.viewport.TotalLineCount(),
                )
        }</span>

        <span class="cov8" title="1">status := statusStyle.Render(statusText)

        // Apply search highlighting to the content if we have search results
        var viewportContent string
        if len(v.searchResults) &gt; 0 &amp;&amp; v.searchQuery != "" </span><span class="cov0" title="0">{
                viewportContent = v.getHighlightedContent()
        }</span> else<span class="cov8" title="1"> {
                viewportContent = v.viewport.View()
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s\n%s\n%s", header, viewportContent, status)</span>
}

// SetSize updates the view size
func (v *LogView) SetSize(width, height int) <span class="cov8" title="1">{
        v.width = width
        v.height = height
        v.viewport.Width = width
        v.viewport.Height = height - 3 // Account for header and status line
        v.ready = true
}</span>

// performSearch searches for the query in the log content
func (v *LogView) performSearch() <span class="cov0" title="0">{
        v.searchResults = []int{}
        if v.searchQuery == "" </span><span class="cov0" title="0">{
                // Clear highlighting by resetting the viewport content
                v.viewport.SetContent(strings.Join(v.content, "\n"))
                return
        }</span>

        <span class="cov0" title="0">query := strings.ToLower(v.searchQuery)
        for i, line := range v.content </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(line), query) </span><span class="cov0" title="0">{
                        v.searchResults = append(v.searchResults, i)
                }</span>
        }

        <span class="cov0" title="0">if len(v.searchResults) &gt; 0 </span><span class="cov0" title="0">{
                v.currentMatch = 0
                v.jumpToMatch()
        }</span>

        // The highlighting will be applied in the View() method
}

// jumpToMatch jumps to the current search match
func (v *LogView) jumpToMatch() <span class="cov0" title="0">{
        if v.currentMatch &gt;= 0 &amp;&amp; v.currentMatch &lt; len(v.searchResults) </span><span class="cov0" title="0">{
                lineIndex := v.searchResults[v.currentMatch]
                // Calculate the position to jump to (center the match if possible)
                v.viewport.YOffset = lineIndex - v.viewport.Height/2

                // Ensure YOffset stays within valid bounds
                if v.viewport.YOffset &lt; 0 </span><span class="cov0" title="0">{
                        v.viewport.YOffset = 0
                }</span>

                <span class="cov0" title="0">maxOffset := v.viewport.TotalLineCount() - v.viewport.Height
                if maxOffset &lt; 0 </span><span class="cov0" title="0">{
                        maxOffset = 0
                }</span>
                <span class="cov0" title="0">if v.viewport.YOffset &gt; maxOffset </span><span class="cov0" title="0">{
                        v.viewport.YOffset = maxOffset
                }</span>

                <span class="cov0" title="0">v.following = false</span> // Disable following when jumping to search result
        }
}

// getHighlightedContent returns the viewport content with search matches highlighted
func (v *LogView) getHighlightedContent() string <span class="cov0" title="0">{
        // Get the visible lines from the viewport
        startLine := v.viewport.YOffset
        if startLine &lt; 0 </span><span class="cov0" title="0">{
                startLine = 0
        }</span>

        <span class="cov0" title="0">endLine := startLine + v.viewport.Height
        if endLine &gt; len(v.content) </span><span class="cov0" title="0">{
                endLine = len(v.content)
        }</span>

        // Style for highlighting matches
        <span class="cov0" title="0">highlightStyle := lipgloss.NewStyle().
                Background(lipgloss.Color("226")). // Yellow background
                Foreground(lipgloss.Color("0"))    // Black text

        // Style for current match (different color)
        currentHighlightStyle := lipgloss.NewStyle().
                Background(lipgloss.Color("202")). // Orange background
                Foreground(lipgloss.Color("15"))   // White text

        var result []string
        query := strings.ToLower(v.searchQuery)

        for i := startLine; i &lt; endLine; i++ </span><span class="cov0" title="0">{
                if i &lt; 0 || i &gt;= len(v.content) </span><span class="cov0" title="0">{
                        result = append(result, "")
                        continue</span>
                }

                <span class="cov0" title="0">line := v.content[i]
                lowerLine := strings.ToLower(line)

                // Check if this line contains the search query
                if strings.Contains(lowerLine, query) </span><span class="cov0" title="0">{
                        // Check if this is the current match line
                        isCurrentMatch := false
                        if v.currentMatch &gt;= 0 &amp;&amp; v.currentMatch &lt; len(v.searchResults) </span><span class="cov0" title="0">{
                                isCurrentMatch = (i == v.searchResults[v.currentMatch])
                        }</span>

                        // Highlight all occurrences in the line
                        <span class="cov0" title="0">highlightedLine := ""
                        lastEnd := 0

                        for </span><span class="cov0" title="0">{
                                idx := strings.Index(lowerLine[lastEnd:], query)
                                if idx == -1 </span><span class="cov0" title="0">{
                                        // No more matches, append the rest
                                        highlightedLine += line[lastEnd:]
                                        break</span>
                                }

                                // Add the part before the match
                                <span class="cov0" title="0">actualIdx := lastEnd + idx
                                highlightedLine += line[lastEnd:actualIdx]

                                // Add the highlighted match
                                matchText := line[actualIdx : actualIdx+len(v.searchQuery)]
                                if isCurrentMatch </span><span class="cov0" title="0">{
                                        highlightedLine += currentHighlightStyle.Render(matchText)
                                }</span> else<span class="cov0" title="0"> {
                                        highlightedLine += highlightStyle.Render(matchText)
                                }</span>

                                <span class="cov0" title="0">lastEnd = actualIdx + len(v.searchQuery)</span>
                        }

                        <span class="cov0" title="0">result = append(result, highlightedLine)</span>
                } else<span class="cov0" title="0"> {
                        result = append(result, line)
                }</span>
        }

        // Pad with empty lines if needed
        <span class="cov0" title="0">for len(result) &lt; v.viewport.Height </span><span class="cov0" title="0">{
                result = append(result, "")
        }</span>

        <span class="cov0" title="0">return strings.Join(result, "\n")</span>
}

// StartStreaming starts streaming logs for the selected resource
func (v *LogView) StartStreaming(ctx context.Context, client *k8s.Client, state *core.State, selectedResourceName string) tea.Cmd <span class="cov0" title="0">{
        // Store for restarting
        v.client = client
        v.state = state
        v.resourceName = selectedResourceName

        v.ctx, v.cancelFunc = context.WithCancel(ctx)
        v.content = []string{}
        v.following = true // Start with auto-follow enabled
        v.tailing = true   // Always tail while streaming
        v.viewport.SetContent("Loading logs...")

        // Reset readers and scanners
        v.logReaders = []io.ReadCloser{}
        v.scanners = []*bufio.Scanner{}
        v.containers = []string{}

        // Reset pod list for new resource
        v.pods = []string{}

        return func() tea.Msg </span><span class="cov0" title="0">{
                var readers []io.ReadCloser
                var containerNames []string
                var err error

                switch state.CurrentResourceType </span>{
                case core.ResourceTypePod:<span class="cov0" title="0">
                        // Find the pod by name
                        for _, pod := range state.Pods </span><span class="cov0" title="0">{
                                if pod.Name == selectedResourceName </span><span class="cov0" title="0">{
                                        // Build list of all container names for selection
                                        allContainers := []string{}
                                        for _, container := range pod.Spec.Containers </span><span class="cov0" title="0">{
                                                allContainers = append(allContainers, container.Name)
                                        }</span>
                                        <span class="cov0" title="0">v.containers = allContainers

                                        // Determine which containers to stream
                                        containersToStream := []string{}
                                        if v.selectedContainer &gt;= 0 &amp;&amp; v.selectedContainer &lt; len(allContainers) </span><span class="cov0" title="0">{
                                                // Stream only selected container
                                                containersToStream = []string{allContainers[v.selectedContainer]}
                                        }</span> else<span class="cov0" title="0"> {
                                                // Stream all containers
                                                containersToStream = allContainers
                                        }</span>

                                        // Stream logs from selected containers
                                        <span class="cov0" title="0">for _, containerName := range containersToStream </span><span class="cov0" title="0">{
                                                reader, err := client.GetPodLogs(v.ctx, pod.Namespace, pod.Name, containerName, true, 100)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        v.content = append(v.content, fmt.Sprintf("[%s] Error: %v", containerName, err))
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">readers = append(readers, reader)
                                                containerNames = append(containerNames, containerName)</span>
                                        }

                                        // Show status message
                                        <span class="cov0" title="0">if v.selectedContainer &gt;= 0 </span><span class="cov0" title="0">{
                                                v.content = append(v.content, fmt.Sprintf("=== Streaming logs from container: %s ===", containersToStream[0]))
                                        }</span> else<span class="cov0" title="0"> if len(pod.Spec.Containers) &gt; 1 </span><span class="cov0" title="0">{
                                                v.content = append(v.content, fmt.Sprintf("=== Streaming logs from %d containers: %v ===", len(containerNames), containerNames))
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                case core.ResourceTypeDeployment:<span class="cov0" title="0">
                        // Find the deployment by name
                        for _, deployment := range state.Deployments </span><span class="cov0" title="0">{
                                if deployment.Name == selectedResourceName </span><span class="cov0" title="0">{
                                        // Get pods for deployment
                                        pods, err := client.GetPodsForDeployment(v.ctx, deployment.Namespace, deployment.Name)
                                        if err == nil &amp;&amp; len(pods) &gt; 0 </span><span class="cov0" title="0">{
                                                // Store pod names for cycling
                                                v.pods = []string{}
                                                allPodNames := []string{}
                                                for _, pod := range pods </span><span class="cov0" title="0">{
                                                        allPodNames = append(allPodNames, pod.Name)
                                                }</span>
                                                <span class="cov0" title="0">v.pods = allPodNames

                                                // Build container list from first pod (assume all pods have same containers)
                                                if len(pods) &gt; 0 </span><span class="cov0" title="0">{
                                                        allContainers := []string{}
                                                        for _, container := range pods[0].Spec.Containers </span><span class="cov0" title="0">{
                                                                allContainers = append(allContainers, container.Name)
                                                        }</span>
                                                        <span class="cov0" title="0">v.containers = allContainers</span>
                                                }

                                                // Determine which pods to stream
                                                <span class="cov0" title="0">podsToStream := pods
                                                if v.selectedPod &gt;= 0 &amp;&amp; v.selectedPod &lt; len(pods) </span><span class="cov0" title="0">{
                                                        // Stream only selected pod
                                                        podsToStream = []v1.Pod{pods[v.selectedPod]}
                                                }</span>

                                                // Determine which containers to stream
                                                <span class="cov0" title="0">containersToStream := v.containers
                                                if v.selectedContainer &gt;= 0 &amp;&amp; v.selectedContainer &lt; len(v.containers) </span><span class="cov0" title="0">{
                                                        // Stream only selected container
                                                        containersToStream = []string{v.containers[v.selectedContainer]}
                                                }</span>

                                                // Stream from selected pods and containers
                                                <span class="cov0" title="0">for _, pod := range podsToStream </span><span class="cov0" title="0">{
                                                        for _, containerName := range containersToStream </span><span class="cov0" title="0">{
                                                                reader, err := client.GetPodLogs(v.ctx, pod.Namespace, pod.Name, containerName, true, 100)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        v.content = append(v.content, fmt.Sprintf("[%s/%s] Error: %v", pod.Name, containerName, err))
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">readers = append(readers, reader)
                                                                // Include pod name in container identifier for deployments
                                                                containerNames = append(containerNames, fmt.Sprintf("%s/%s", pod.Name, containerName))</span>
                                                        }
                                                }

                                                // Show status message
                                                <span class="cov0" title="0">statusMsg := ""
                                                if v.selectedPod &gt;= 0 </span><span class="cov0" title="0">{
                                                        statusMsg = fmt.Sprintf("Pod: %s", allPodNames[v.selectedPod])
                                                }</span> else<span class="cov0" title="0"> {
                                                        statusMsg = fmt.Sprintf("%d pods", len(podsToStream))
                                                }</span>
                                                <span class="cov0" title="0">if v.selectedContainer &gt;= 0 </span><span class="cov0" title="0">{
                                                        statusMsg += fmt.Sprintf(", Container: %s", v.containers[v.selectedContainer])
                                                }</span> else<span class="cov0" title="0"> {
                                                        statusMsg += fmt.Sprintf(", %d containers", len(containersToStream))
                                                }</span>
                                                <span class="cov0" title="0">v.content = append(v.content, fmt.Sprintf("=== Streaming logs: %s ===", statusMsg))</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                        // Find the statefulset by name
                        for _, sts := range state.StatefulSets </span><span class="cov0" title="0">{
                                if sts.Name == selectedResourceName </span><span class="cov0" title="0">{
                                        // Get pods for statefulset
                                        pods, err := client.GetPodsForStatefulSet(v.ctx, sts.Namespace, sts.Name)
                                        if err == nil &amp;&amp; len(pods) &gt; 0 </span><span class="cov0" title="0">{
                                                // Store pod names for cycling
                                                v.pods = []string{}
                                                allPodNames := []string{}
                                                for _, pod := range pods </span><span class="cov0" title="0">{
                                                        allPodNames = append(allPodNames, pod.Name)
                                                }</span>
                                                <span class="cov0" title="0">v.pods = allPodNames

                                                // Build container list from first pod
                                                if len(pods) &gt; 0 </span><span class="cov0" title="0">{
                                                        allContainers := []string{}
                                                        for _, container := range pods[0].Spec.Containers </span><span class="cov0" title="0">{
                                                                allContainers = append(allContainers, container.Name)
                                                        }</span>
                                                        <span class="cov0" title="0">v.containers = allContainers</span>
                                                }

                                                // Determine which pods to stream
                                                <span class="cov0" title="0">podsToStream := pods
                                                if v.selectedPod &gt;= 0 &amp;&amp; v.selectedPod &lt; len(pods) </span><span class="cov0" title="0">{
                                                        // Stream only selected pod
                                                        podsToStream = []v1.Pod{pods[v.selectedPod]}
                                                }</span>

                                                // Determine which containers to stream
                                                <span class="cov0" title="0">containersToStream := v.containers
                                                if v.selectedContainer &gt;= 0 &amp;&amp; v.selectedContainer &lt; len(v.containers) </span><span class="cov0" title="0">{
                                                        // Stream only selected container
                                                        containersToStream = []string{v.containers[v.selectedContainer]}
                                                }</span>

                                                // Stream from selected pods and containers
                                                <span class="cov0" title="0">for _, pod := range podsToStream </span><span class="cov0" title="0">{
                                                        for _, containerName := range containersToStream </span><span class="cov0" title="0">{
                                                                reader, err := client.GetPodLogs(v.ctx, pod.Namespace, pod.Name, containerName, true, 100)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        v.content = append(v.content, fmt.Sprintf("[%s/%s] Error: %v", pod.Name, containerName, err))
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">readers = append(readers, reader)
                                                                containerNames = append(containerNames, fmt.Sprintf("%s/%s", pod.Name, containerName))</span>
                                                        }
                                                }

                                                // Show status message
                                                <span class="cov0" title="0">statusMsg := ""
                                                if v.selectedPod &gt;= 0 </span><span class="cov0" title="0">{
                                                        statusMsg = fmt.Sprintf("Pod: %s", allPodNames[v.selectedPod])
                                                }</span> else<span class="cov0" title="0"> {
                                                        statusMsg = fmt.Sprintf("%d pods", len(podsToStream))
                                                }</span>
                                                <span class="cov0" title="0">if v.selectedContainer &gt;= 0 </span><span class="cov0" title="0">{
                                                        statusMsg += fmt.Sprintf(", Container: %s", v.containers[v.selectedContainer])
                                                }</span> else<span class="cov0" title="0"> {
                                                        statusMsg += fmt.Sprintf(", %d containers", len(containersToStream))
                                                }</span>
                                                <span class="cov0" title="0">v.content = append(v.content, fmt.Sprintf("=== Streaming logs: %s ===", statusMsg))</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if err != nil &amp;&amp; len(readers) == 0 </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                <span class="cov0" title="0">if len(readers) &gt; 0 </span><span class="cov0" title="0">{
                        v.logReaders = readers
                        v.containers = containerNames
                        // Create scanners for each reader
                        for _, reader := range readers </span><span class="cov0" title="0">{
                                v.scanners = append(v.scanners, bufio.NewScanner(reader))
                        }</span>
                        // Return a message to trigger the first read
                        <span class="cov0" title="0">return logStreamStartedMsg{containerCount: len(readers)}</span>
                }

                <span class="cov0" title="0">return errMsg{fmt.Errorf("no logs available for selected resource")}</span>
        }
}

// StopStreaming stops streaming logs
func (v *LogView) StopStreaming() tea.Cmd <span class="cov8" title="1">{
        if v.cancelFunc != nil </span><span class="cov0" title="0">{
                v.cancelFunc()
        }</span>
        // Close all readers
        <span class="cov8" title="1">for _, reader := range v.logReaders </span><span class="cov0" title="0">{
                if reader != nil </span><span class="cov0" title="0">{
                        reader.Close()
                }</span>
        }
        <span class="cov8" title="1">v.logReaders = nil
        v.scanners = nil
        v.tailing = false
        return nil</span>
}

// restartStreaming stops current streams and restarts with current filter settings
func (v *LogView) restartStreaming() tea.Cmd <span class="cov8" title="1">{
        // Stop current streams
        if v.cancelFunc != nil </span><span class="cov0" title="0">{
                v.cancelFunc()
        }</span>
        <span class="cov8" title="1">for _, reader := range v.logReaders </span><span class="cov0" title="0">{
                if reader != nil </span><span class="cov0" title="0">{
                        reader.Close()
                }</span>
        }
        <span class="cov8" title="1">v.logReaders = nil
        v.scanners = nil

        // Clear content but keep filter settings
        v.content = []string{"Restarting streams with new filters..."}
        v.viewport.SetContent(strings.Join(v.content, "\n"))

        // Restart with same resource but current filter settings
        if v.client != nil &amp;&amp; v.state != nil &amp;&amp; v.resourceName != "" </span><span class="cov0" title="0">{
                // Create new context for the new streams
                parentCtx := context.Background()
                v.ctx, v.cancelFunc = context.WithCancel(parentCtx)
                return v.StartStreaming(v.ctx, v.client, v.state, v.resourceName)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// readNextLine reads the next line from a specific container's log stream
func (v *LogView) readNextLine(containerIndex int) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if containerIndex &gt;= len(v.scanners) || containerIndex &gt;= len(v.containers) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">scanner := v.scanners[containerIndex]
                containerName := v.containers[containerIndex]

                if scanner == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if context is cancelled
                <span class="cov0" title="0">select </span>{
                case &lt;-v.ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0"></span>
                }

                // Read in a goroutine to avoid blocking
                <span class="cov0" title="0">lineChan := make(chan string, 1)
                errChan := make(chan error, 1)

                go func() </span><span class="cov0" title="0">{
                        if scanner.Scan() </span><span class="cov0" title="0">{
                                lineChan &lt;- scanner.Text()
                        }</span> else<span class="cov0" title="0"> if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                        }</span> else<span class="cov0" title="0"> {
                                // EOF or stream closed
                                errChan &lt;- io.EOF
                        }</span>
                }()

                // Wait for result with timeout
                <span class="cov0" title="0">select </span>{
                case &lt;-v.ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case line := &lt;-lineChan:<span class="cov0" title="0">
                        return logLineMsg{container: containerName, line: line}</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // Stream ended, this shouldn't happen with follow=true
                                // but can happen if pod terminates
                                return logLineMsg{container: containerName, line: "--- End of logs (pod may have terminated) ---"}
                        }</span>
                        <span class="cov0" title="0">return errMsg{err}</span>
                case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                        // No data yet, check again
                        return v.readNextLine(containerIndex)()</span>
                }
        }
}

// Message types
type logLineMsg struct {
        container string
        line      string
}
type logStreamStartedMsg struct {
        containerCount int
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package views

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        v1 "k8s.io/api/core/v1"
)

// NamespaceView displays a list of namespaces for selection
type NamespaceView struct {
        namespaces       []v1.Namespace
        filteredItems    []v1.Namespace
        selectedIndex    int
        filter           string
        width            int
        height           int
        currentNamespace string
}

// NewNamespaceView creates a new namespace selector view
func NewNamespaceView(namespaces []v1.Namespace, currentNamespace string) *NamespaceView <span class="cov0" title="0">{
        nv := &amp;NamespaceView{
                namespaces:       namespaces,
                filteredItems:    namespaces,
                currentNamespace: currentNamespace,
        }

        // Pre-select the current namespace
        for i, ns := range namespaces </span><span class="cov0" title="0">{
                if ns.Name == currentNamespace </span><span class="cov0" title="0">{
                        nv.selectedIndex = i
                        break</span>
                }
        }

        // Add "all" option at the beginning
        <span class="cov0" title="0">allNs := v1.Namespace{}
        allNs.Name = "all"
        nv.namespaces = append([]v1.Namespace{allNs}, namespaces...)
        nv.filteredItems = nv.namespaces

        // Adjust selection if current namespace is "all" or empty
        if currentNamespace == "" || currentNamespace == "all" </span><span class="cov0" title="0">{
                nv.selectedIndex = 0
        }</span> else<span class="cov0" title="0"> {
                nv.selectedIndex++ // Adjust for the "all" option we added
        }</span>

        <span class="cov0" title="0">return nv</span>
}

// Init initializes the view
func (v *NamespaceView) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles messages
func (v *NamespaceView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if v.selectedIndex &gt; 0 </span><span class="cov0" title="0">{
                                v.selectedIndex--
                        }</span>
                case "down", "j":<span class="cov0" title="0">
                        if v.selectedIndex &lt; len(v.filteredItems)-1 </span><span class="cov0" title="0">{
                                v.selectedIndex++
                        }</span>
                case "home":<span class="cov0" title="0">
                        v.selectedIndex = 0</span>
                case "end":<span class="cov0" title="0">
                        v.selectedIndex = len(v.filteredItems) - 1</span>
                case "pgup":<span class="cov0" title="0">
                        v.selectedIndex -= 10
                        if v.selectedIndex &lt; 0 </span><span class="cov0" title="0">{
                                v.selectedIndex = 0
                        }</span>
                case "pgdown":<span class="cov0" title="0">
                        v.selectedIndex += 10
                        if v.selectedIndex &gt;= len(v.filteredItems) </span><span class="cov0" title="0">{
                                v.selectedIndex = len(v.filteredItems) - 1
                        }</span>
                case "/":<span class="cov0" title="0">
                        // Start filtering
                        v.filter = ""</span>
                case "backspace":<span class="cov0" title="0">
                        if len(v.filter) &gt; 0 </span><span class="cov0" title="0">{
                                v.filter = v.filter[:len(v.filter)-1]
                                v.applyFilter()
                        }</span>
                case "esc":<span class="cov0" title="0">
                        // Clear filter
                        v.filter = ""
                        v.applyFilter()</span>
                case "enter":<span class="cov0" title="0">
                        // Selection made - will be handled by parent
                        return v, nil</span>
                case "q", "n":<span class="cov0" title="0">
                        // Cancel - will be handled by parent
                        return v, nil</span>
                default:<span class="cov0" title="0">
                        // Add to filter if it's a printable character
                        if len(msg.String()) == 1 &amp;&amp; msg.String()[0] &gt;= 32 &amp;&amp; msg.String()[0] &lt; 127 </span><span class="cov0" title="0">{
                                v.filter += msg.String()
                                v.applyFilter()
                        }</span>
                }
        }
        <span class="cov0" title="0">return v, nil</span>
}

// View renders the namespace selector
func (v *NamespaceView) View() string <span class="cov0" title="0">{
        // Create styles
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(1)

        borderStyle := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("62")).
                Padding(1, 2).
                Width(50).
                Height(20)

        selectedStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("229")).
                Background(lipgloss.Color("57")).
                Bold(true)

        currentStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("2")).
                Bold(true)

        filterStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("3")).
                Italic(true)

        // Build content
        var content strings.Builder

        title := "Select Namespace"
        content.WriteString(titleStyle.Render(title))
        content.WriteString("\n\n")

        // Show filter if active
        if v.filter != "" </span><span class="cov0" title="0">{
                content.WriteString(filterStyle.Render(fmt.Sprintf("Filter: %s", v.filter)))
                content.WriteString("\n\n")
        }</span>

        // Calculate visible range (show 15 items)
        <span class="cov0" title="0">visibleItems := 15
        startIdx := 0
        endIdx := len(v.filteredItems)

        // Adjust viewport to keep selection visible
        if v.selectedIndex &gt;= visibleItems </span><span class="cov0" title="0">{
                startIdx = v.selectedIndex - visibleItems/2
                if startIdx &lt; 0 </span><span class="cov0" title="0">{
                        startIdx = 0
                }</span>
        }

        <span class="cov0" title="0">if endIdx &gt; startIdx+visibleItems </span><span class="cov0" title="0">{
                endIdx = startIdx + visibleItems
        }</span>

        // List namespaces
        <span class="cov0" title="0">for i := startIdx; i &lt; endIdx &amp;&amp; i &lt; len(v.filteredItems); i++ </span><span class="cov0" title="0">{
                ns := v.filteredItems[i]
                line := ns.Name

                // Add status for special namespaces
                if ns.Name == "all" </span><span class="cov0" title="0">{
                        line = "📁 All Namespaces"
                }</span> else<span class="cov0" title="0"> if ns.Name == v.currentNamespace </span><span class="cov0" title="0">{
                        line = fmt.Sprintf("• %s", line)
                }</span> else<span class="cov0" title="0"> {
                        line = fmt.Sprintf("  %s", line)
                }</span>

                // Apply styling
                <span class="cov0" title="0">if i == v.selectedIndex </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(fmt.Sprintf("→ %s", line))
                }</span> else<span class="cov0" title="0"> if ns.Name == v.currentNamespace &amp;&amp; ns.Name != "all" </span><span class="cov0" title="0">{
                        line = currentStyle.Render(line)
                }</span>

                <span class="cov0" title="0">content.WriteString(line)
                content.WriteString("\n")</span>
        }

        // Add scroll indicator if needed
        <span class="cov0" title="0">if len(v.filteredItems) &gt; visibleItems </span><span class="cov0" title="0">{
                scrollInfo := fmt.Sprintf("\n[%d-%d of %d]", startIdx+1, endIdx, len(v.filteredItems))
                content.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(scrollInfo))
        }</span>

        // Add help text
        <span class="cov0" title="0">helpText := "\n\n[↑↓/jk] Navigate  [/] Filter  [Enter] Select  [Esc/q/n] Cancel"
        content.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(helpText))

        // Center the popup
        return lipgloss.Place(
                v.width,
                v.height,
                lipgloss.Center,
                lipgloss.Center,
                borderStyle.Render(content.String()),
        )</span>
}

// SetSize updates the view size
func (v *NamespaceView) SetSize(width, height int) <span class="cov0" title="0">{
        v.width = width
        v.height = height
}</span>

// GetSelectedNamespace returns the selected namespace name
func (v *NamespaceView) GetSelectedNamespace() string <span class="cov0" title="0">{
        if v.selectedIndex &gt;= 0 &amp;&amp; v.selectedIndex &lt; len(v.filteredItems) </span><span class="cov0" title="0">{
                ns := v.filteredItems[v.selectedIndex]
                if ns.Name == "all" </span><span class="cov0" title="0">{
                        return "" // Empty string means all namespaces
                }</span>
                <span class="cov0" title="0">return ns.Name</span>
        }
        <span class="cov0" title="0">return v.currentNamespace</span>
}

// applyFilter filters the namespace list based on the current filter string
func (v *NamespaceView) applyFilter() <span class="cov0" title="0">{
        if v.filter == "" </span><span class="cov0" title="0">{
                v.filteredItems = v.namespaces
                return
        }</span>

        <span class="cov0" title="0">v.filteredItems = []v1.Namespace{}
        filterLower := strings.ToLower(v.filter)

        for _, ns := range v.namespaces </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(ns.Name), filterLower) </span><span class="cov0" title="0">{
                        v.filteredItems = append(v.filteredItems, ns)
                }</span>
        }

        // Reset selection to first item if current selection is out of bounds
        <span class="cov0" title="0">if v.selectedIndex &gt;= len(v.filteredItems) </span><span class="cov0" title="0">{
                v.selectedIndex = 0
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package views

import (
        "context"
        "fmt"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/HamStudy/kubewatch/internal/core"
        "github.com/HamStudy/kubewatch/internal/k8s"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        appsv1 "k8s.io/api/apps/v1"
        v1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
)

// ResourceView displays a list of Kubernetes resources
// ResourceIdentity uniquely identifies a Kubernetes resource
type ResourceIdentity struct {
        Context   string // Kubernetes context (for multi-context mode)
        Namespace string // Kubernetes namespace
        Name      string // Resource name
        UID       string // Kubernetes UID (most unique identifier)
        Kind      string // Resource kind (Pod, Deployment, etc.)
}

type ResourceView struct {
        state            *core.State
        k8sClient        *k8s.Client
        width            int
        height           int
        wordWrap         bool
        showMetrics      bool
        podMetrics       map[string]*k8s.PodMetrics
        horizontalOffset int
        lastRefresh      time.Time
        compactMode      bool // For split view with logs

        // Multi-context support
        multiClient       *k8s.MultiContextClient
        isMultiContext    bool
        showContextColumn bool

        // Custom table data
        headers        []string
        rows           [][]string
        columnWidths   []int
        selectedRow    int
        viewportStart  int
        viewportHeight int

        // Selection tracking
        selectedIdentity *ResourceIdentity         // Track the actual selected resource
        resourceMap      map[int]*ResourceIdentity // Map row index to resource identity
}

// NewResourceView creates a new resource view
func NewResourceView(state *core.State, k8sClient *k8s.Client) *ResourceView <span class="cov8" title="1">{
        rv := &amp;ResourceView{
                state:             state,
                k8sClient:         k8sClient,
                wordWrap:          false,
                showMetrics:       true,
                podMetrics:        make(map[string]*k8s.PodMetrics),
                selectedRow:       0,
                isMultiContext:    false,
                showContextColumn: false,
                resourceMap:       make(map[int]*ResourceIdentity),
        }

        // Set initial columns based on resource type
        rv.updateColumnsForResourceType()

        return rv
}</span>

// NewResourceViewWithMultiContext creates a new resource view with multi-context support
func NewResourceViewWithMultiContext(state *core.State, multiClient *k8s.MultiContextClient) *ResourceView <span class="cov8" title="1">{
        rv := &amp;ResourceView{
                state:             state,
                multiClient:       multiClient,
                wordWrap:          false,
                showMetrics:       true,
                podMetrics:        make(map[string]*k8s.PodMetrics),
                selectedRow:       0,
                isMultiContext:    true,
                showContextColumn: true,
                resourceMap:       make(map[int]*ResourceIdentity),
        }

        // Set initial columns based on resource type
        rv.updateColumnsForResourceType()

        return rv
}</span>

// Init initializes the view
func (v *ResourceView) Init() tea.Cmd <span class="cov8" title="1">{
        return v.RefreshResources()
}</span>

// Update handles messages
func (v *ResourceView) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                switch msg.String() </span>{
                case "j", "down":<span class="cov8" title="1">
                        // Move down
                        if v.selectedRow &lt; len(v.rows)-1 </span><span class="cov8" title="1">{
                                v.selectedRow++
                                v.updateSelectedIdentity()
                        }</span>
                        <span class="cov8" title="1">return v, nil</span>
                case "k", "up":<span class="cov8" title="1">
                        // Move up
                        if v.selectedRow &gt; 0 </span><span class="cov8" title="1">{
                                v.selectedRow--
                                v.updateSelectedIdentity()
                        }</span>
                        <span class="cov8" title="1">return v, nil</span>
                case "u":<span class="cov8" title="1">
                        // Toggle word wrap
                        v.wordWrap = !v.wordWrap
                        return v, nil</span>
                case "home":<span class="cov8" title="1">
                        v.selectedRow = 0
                        v.updateSelectedIdentity()
                        return v, nil</span>
                case "end":<span class="cov8" title="1">
                        if len(v.rows) &gt; 0 </span><span class="cov8" title="1">{
                                v.selectedRow = len(v.rows) - 1
                                v.updateSelectedIdentity()
                        }</span>
                        <span class="cov8" title="1">return v, nil</span>
                case "pgup":<span class="cov8" title="1">
                        // Page up
                        if v.selectedRow &gt; v.viewportHeight </span><span class="cov0" title="0">{
                                v.selectedRow -= v.viewportHeight
                        }</span> else<span class="cov8" title="1"> {
                                v.selectedRow = 0
                        }</span>
                        <span class="cov8" title="1">v.updateSelectedIdentity()
                        return v, nil</span>
                case "pgdown":<span class="cov8" title="1">
                        // Page down
                        if v.selectedRow &lt; len(v.rows)-v.viewportHeight </span><span class="cov8" title="1">{
                                v.selectedRow += v.viewportHeight
                        }</span> else<span class="cov0" title="0"> if len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                                v.selectedRow = len(v.rows) - 1
                        }</span>
                        <span class="cov8" title="1">v.updateSelectedIdentity()
                        return v, nil</span>
                case "h", "left":<span class="cov0" title="0">
                        // Scroll left
                        if v.horizontalOffset &gt; 0 </span><span class="cov0" title="0">{
                                v.horizontalOffset -= 5
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                case "l", "right":<span class="cov0" title="0">
                        // Scroll right
                        v.horizontalOffset += 5
                        return v, nil</span>
                }
        }

        <span class="cov0" title="0">return v, nil</span>
}

// View renders the view
func (v *ResourceView) View() string <span class="cov8" title="1">{
        header := v.renderHeader()
        // Use custom renderer instead of table.View()
        tableView := v.renderCustomTable()
        return lipgloss.JoinVertical(lipgloss.Left, header, tableView)
}</span>

// SetSize updates the view size
func (v *ResourceView) SetSize(width, height int) <span class="cov8" title="1">{
        v.width = width
        v.height = height
        if v.compactMode </span><span class="cov0" title="0">{
                // In compact mode, ensure selected item stays visible with minimal context
                v.viewportHeight = height - 3 // Less space for header in compact mode
        }</span> else<span class="cov8" title="1"> {
                v.viewportHeight = height - 6 // Account for header and borders
        }</span>
}

// SetCompactMode enables/disables compact mode for split view
func (v *ResourceView) SetCompactMode(compact bool) <span class="cov8" title="1">{
        v.compactMode = compact
        if compact </span><span class="cov8" title="1">{
                // Adjust viewport to keep selected item visible
                v.ensureSelectedVisible()
        }</span>
}

// ensureSelectedVisible adjusts viewport to keep selected item in view
func (v *ResourceView) ensureSelectedVisible() <span class="cov8" title="1">{
        // First ensure selectedRow is within bounds
        if v.selectedRow &gt;= len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = len(v.rows) - 1
        }</span>
        <span class="cov8" title="1">if v.selectedRow &lt; 0 &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = 0
        }</span>

        // Ensure viewportStart is within bounds
        <span class="cov8" title="1">if v.viewportStart &gt;= len(v.rows) </span><span class="cov0" title="0">{
                v.viewportStart = 0
                if len(v.rows) &gt; v.viewportHeight </span><span class="cov0" title="0">{
                        v.viewportStart = len(v.rows) - v.viewportHeight
                }</span>
        }
        <span class="cov8" title="1">if v.viewportStart &lt; 0 </span><span class="cov0" title="0">{
                v.viewportStart = 0
        }</span>

        // Adjust viewport to keep selected item visible
        <span class="cov8" title="1">if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span> else<span class="cov8" title="1"> if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span>

        // Ensure we show at least 3 items around selected if possible
        <span class="cov8" title="1">contextRows := 3
        if v.viewportHeight &gt; contextRows*2 &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov8" title="1">{
                idealStart := v.selectedRow - contextRows
                if idealStart &gt;= 0 &amp;&amp; idealStart+v.viewportHeight &lt;= len(v.rows) </span><span class="cov0" title="0">{
                        v.viewportStart = idealStart
                }</span>
        }
}

// RefreshResources fetches and updates the resource list
func (v *ResourceView) RefreshResources() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx := context.Background()

                if v.isMultiContext &amp;&amp; v.multiClient != nil </span><span class="cov0" title="0">{
                        return v.refreshMultiContextResources(ctx)
                }</span>

                // Check if we have a valid client
                <span class="cov0" title="0">if v.k8sClient == nil </span><span class="cov0" title="0">{
                        return errMsg{fmt.Errorf("no kubernetes client available")}
                }</span>

                <span class="cov0" title="0">switch v.state.CurrentResourceType </span>{
                case core.ResourceTypePod:<span class="cov0" title="0">
                        pods, err := v.k8sClient.ListPods(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>

                        // Try to get metrics (don't fail if not available)
                        <span class="cov0" title="0">metrics, _ := v.k8sClient.GetPodMetrics(ctx, v.state.CurrentNamespace)
                        v.podMetrics = metrics

                        v.state.UpdatePods(pods)
                        v.updateTableWithPods(pods)</span>

                case core.ResourceTypeDeployment:<span class="cov0" title="0">
                        deployments, err := v.k8sClient.ListDeployments(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateDeployments(deployments)
                        v.updateTableWithDeployments(deployments)</span>

                case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                        statefulsets, err := v.k8sClient.ListStatefulSets(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateStatefulSets(statefulsets)
                        v.updateTableWithStatefulSets(statefulsets)</span>

                case core.ResourceTypeService:<span class="cov0" title="0">
                        services, err := v.k8sClient.ListServices(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateServices(services)
                        v.updateTableWithServices(services)</span>

                case core.ResourceTypeIngress:<span class="cov0" title="0">
                        ingresses, err := v.k8sClient.ListIngresses(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateIngresses(ingresses)
                        v.updateTableWithIngresses(ingresses)</span>

                case core.ResourceTypeConfigMap:<span class="cov0" title="0">
                        configmaps, err := v.k8sClient.ListConfigMaps(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateConfigMaps(configmaps)
                        v.updateTableWithConfigMaps(configmaps)</span>

                case core.ResourceTypeSecret:<span class="cov0" title="0">
                        secrets, err := v.k8sClient.ListSecrets(ctx, v.state.CurrentNamespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.state.UpdateSecrets(secrets)
                        v.updateTableWithSecrets(secrets)</span>
                }

                // Update last refresh time
                <span class="cov0" title="0">v.lastRefresh = time.Now()

                return refreshCompleteMsg{}</span>
        }
}

// refreshMultiContextResources fetches resources from all active contexts
func (v *ResourceView) refreshMultiContextResources(ctx context.Context) tea.Msg <span class="cov0" title="0">{
        switch v.state.CurrentResourceType </span>{
        case core.ResourceTypePod:<span class="cov0" title="0">
                podsWithContext, err := v.multiClient.ListPodsAllContexts(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Update state with aggregated pods
                <span class="cov0" title="0">var allPods []v1.Pod
                for _, pwc := range podsWithContext </span><span class="cov0" title="0">{
                        allPods = append(allPods, pwc.Pod)
                        // Store pods by context
                        v.state.UpdatePodsByContext(pwc.Context, []v1.Pod{pwc.Pod})
                }</span>

                <span class="cov0" title="0">v.state.UpdatePods(allPods)
                v.updateTableWithPodsMultiContext(podsWithContext)</span>

        case core.ResourceTypeDeployment:<span class="cov0" title="0">
                deploymentsWithContext, err := v.multiClient.ListDeploymentsAllContexts(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Update state with aggregated deployments
                <span class="cov0" title="0">var allDeployments []appsv1.Deployment
                for _, dwc := range deploymentsWithContext </span><span class="cov0" title="0">{
                        allDeployments = append(allDeployments, dwc.Deployment)
                        v.state.UpdateDeploymentsByContext(dwc.Context, []appsv1.Deployment{dwc.Deployment})
                }</span>

                <span class="cov0" title="0">v.state.UpdateDeployments(allDeployments)
                v.updateTableWithDeploymentsMultiContext(deploymentsWithContext)</span>

        // Add other resource types as needed
        default:<span class="cov0" title="0">
                // For now, fall back to single context for unsupported resource types
                if len(v.state.CurrentContexts) &gt; 0 </span><span class="cov0" title="0">{
                        client, err := v.multiClient.GetClient(v.state.CurrentContexts[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                        <span class="cov0" title="0">v.k8sClient = client
                        return v.refreshSingleContextResources(ctx)</span>
                }
        }

        // Update last refresh time
        <span class="cov0" title="0">v.lastRefresh = time.Now()
        return refreshCompleteMsg{}</span>
}

// refreshSingleContextResources is the original single-context refresh logic
func (v *ResourceView) refreshSingleContextResources(ctx context.Context) tea.Msg <span class="cov0" title="0">{
        switch v.state.CurrentResourceType </span>{
        case core.ResourceTypePod:<span class="cov0" title="0">
                pods, err := v.k8sClient.ListPods(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Try to get metrics (don't fail if not available)
                <span class="cov0" title="0">metrics, _ := v.k8sClient.GetPodMetrics(ctx, v.state.CurrentNamespace)
                v.podMetrics = metrics

                v.state.UpdatePods(pods)
                v.updateTableWithPods(pods)</span>

        case core.ResourceTypeDeployment:<span class="cov0" title="0">
                deployments, err := v.k8sClient.ListDeployments(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateDeployments(deployments)
                v.updateTableWithDeployments(deployments)</span>

        case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                statefulsets, err := v.k8sClient.ListStatefulSets(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateStatefulSets(statefulsets)
                v.updateTableWithStatefulSets(statefulsets)</span>

        case core.ResourceTypeService:<span class="cov0" title="0">
                services, err := v.k8sClient.ListServices(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateServices(services)
                v.updateTableWithServices(services)</span>

        case core.ResourceTypeIngress:<span class="cov0" title="0">
                ingresses, err := v.k8sClient.ListIngresses(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateIngresses(ingresses)
                v.updateTableWithIngresses(ingresses)</span>

        case core.ResourceTypeConfigMap:<span class="cov0" title="0">
                configmaps, err := v.k8sClient.ListConfigMaps(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateConfigMaps(configmaps)
                v.updateTableWithConfigMaps(configmaps)</span>

        case core.ResourceTypeSecret:<span class="cov0" title="0">
                secrets, err := v.k8sClient.ListSecrets(ctx, v.state.CurrentNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">v.state.UpdateSecrets(secrets)
                v.updateTableWithSecrets(secrets)</span>
        }

        // Update last refresh time
        <span class="cov0" title="0">v.lastRefresh = time.Now()
        return refreshCompleteMsg{}</span>
}

// GetSelectedResourceName returns the name of the currently selected resource
func (v *ResourceView) GetSelectedResourceName() string <span class="cov8" title="1">{
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov8" title="1">{
                selectedRow := v.rows[v.selectedRow]
                if v.isMultiContext &amp;&amp; v.showContextColumn &amp;&amp; len(selectedRow) &gt;= 2 </span><span class="cov0" title="0">{
                        return selectedRow[1] // Second column is NAME in multi-context mode
                }</span> else<span class="cov8" title="1"> if len(selectedRow) &gt;= 1 </span><span class="cov8" title="1">{
                        return selectedRow[0] // First column is NAME in single context mode
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// GetSelectedResourceContext returns the context of the currently selected resource (multi-context mode)
func (v *ResourceView) GetSelectedResourceContext() string <span class="cov8" title="1">{
        if !v.isMultiContext </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov0" title="0">if v.selectedIdentity != nil </span><span class="cov0" title="0">{
                return v.selectedIdentity.Context
        }</span>

        // Fallback to old method if identity not available
        <span class="cov0" title="0">if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedRow := v.rows[v.selectedRow]
                if len(selectedRow) &gt;= 1 </span><span class="cov0" title="0">{
                        return selectedRow[0] // First column is CONTEXT in multi-context mode
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// saveSelectedIdentity stores the identity of the currently selected resource
func (v *ResourceView) saveSelectedIdentity() <span class="cov0" title="0">{
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) </span><span class="cov0" title="0">{
                if identity, exists := v.resourceMap[v.selectedRow]; exists </span><span class="cov0" title="0">{
                        v.selectedIdentity = identity
                }</span>
        }
}

// updateSelectedIdentity updates the selected identity when selection changes
func (v *ResourceView) updateSelectedIdentity() <span class="cov8" title="1">{
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) </span><span class="cov8" title="1">{
                if identity, exists := v.resourceMap[v.selectedRow]; exists </span><span class="cov8" title="1">{
                        v.selectedIdentity = identity
                }</span>
        }
}

// findResourceByIdentity searches for a resource by its identity and returns the row index
func (v *ResourceView) findResourceByIdentity(identity *ResourceIdentity) int <span class="cov8" title="1">{
        if identity == nil </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">for rowIndex, resourceIdentity := range v.resourceMap </span><span class="cov8" title="1">{
                if resourceIdentity != nil &amp;&amp;
                        resourceIdentity.UID == identity.UID &amp;&amp;
                        resourceIdentity.Context == identity.Context &amp;&amp;
                        resourceIdentity.Namespace == identity.Namespace &amp;&amp;
                        resourceIdentity.Name == identity.Name </span><span class="cov8" title="1">{
                        return rowIndex
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// restoreSelectionByIdentity attempts to restore the previously selected resource by identity
func (v *ResourceView) restoreSelectionByIdentity() <span class="cov8" title="1">{
        if v.selectedIdentity == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Try to find the resource by its identity
        <span class="cov8" title="1">newIndex := v.findResourceByIdentity(v.selectedIdentity)
        if newIndex &gt;= 0 </span><span class="cov8" title="1">{
                v.selectedRow = newIndex
                return
        }</span>

        // If exact match not found, try to find by name and context (less precise)
        <span class="cov0" title="0">for rowIndex, identity := range v.resourceMap </span><span class="cov0" title="0">{
                if identity != nil &amp;&amp;
                        identity.Name == v.selectedIdentity.Name &amp;&amp;
                        identity.Context == v.selectedIdentity.Context &amp;&amp;
                        identity.Namespace == v.selectedIdentity.Namespace </span><span class="cov0" title="0">{
                        v.selectedRow = rowIndex
                        return
                }</span>
        }

        // If still not found, keep current index but ensure it's valid
        <span class="cov0" title="0">if v.selectedRow &gt;= len(v.rows) </span><span class="cov0" title="0">{
                v.selectedRow = len(v.rows) - 1
        }</span>
        <span class="cov0" title="0">if v.selectedRow &lt; 0 &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = 0
        }</span>
}

// DeleteSelected deletes the selected resource(s)
func (v *ResourceView) DeleteSelected() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx := context.Background()

                // Check if we have a selected row
                if v.selectedRow &gt;= len(v.rows) || v.selectedRow &lt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">selectedRow := v.rows[v.selectedRow]
                if len(selectedRow) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Extract name and context based on multi-context mode
                <span class="cov0" title="0">var name, contextName string
                var client *k8s.Client

                if v.isMultiContext &amp;&amp; v.showContextColumn </span><span class="cov0" title="0">{
                        // In multi-context mode: [CONTEXT, NAME, ...]
                        if len(selectedRow) &lt; 2 </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">contextName = selectedRow[0]
                        name = selectedRow[1]

                        // Get the appropriate client for this context
                        var err error
                        client, err = v.multiClient.GetClient(contextName)
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg{err}
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Single context mode: [NAME, ...]
                        name = selectedRow[0]
                        client = v.k8sClient
                }</span>

                <span class="cov0" title="0">namespace := v.state.CurrentNamespace

                var err error
                switch v.state.CurrentResourceType </span>{
                case core.ResourceTypePod:<span class="cov0" title="0">
                        err = client.DeletePod(ctx, namespace, name)</span>
                case core.ResourceTypeDeployment:<span class="cov0" title="0">
                        err = client.DeleteDeployment(ctx, namespace, name)</span>
                case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                        err = client.DeleteStatefulSet(ctx, namespace, name)</span>
                case core.ResourceTypeService:<span class="cov0" title="0">
                        err = client.DeleteService(ctx, namespace, name)</span>
                case core.ResourceTypeIngress:<span class="cov0" title="0">
                        err = client.DeleteIngress(ctx, namespace, name)</span>
                case core.ResourceTypeConfigMap:<span class="cov0" title="0">
                        err = client.DeleteConfigMap(ctx, namespace, name)</span>
                case core.ResourceTypeSecret:<span class="cov0" title="0">
                        err = client.DeleteSecret(ctx, namespace, name)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                <span class="cov0" title="0">return deleteCompleteMsg{name}</span>
        }
}

// renderCustomTable renders the table using lipgloss styling
func (v *ResourceView) renderCustomTable() string <span class="cov8" title="1">{
        if len(v.headers) == 0 || len(v.rows) == 0 </span><span class="cov8" title="1">{
                return "No resources found"
        }</span>

        // Ensure selectedRow is within bounds
        <span class="cov8" title="1">if v.selectedRow &gt;= len(v.rows) </span><span class="cov0" title="0">{
                v.selectedRow = len(v.rows) - 1
        }</span>
        <span class="cov8" title="1">if v.selectedRow &lt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = 0
        }</span>

        // Ensure columnWidths is initialized and matches headers
        <span class="cov8" title="1">if len(v.columnWidths) != len(v.headers) </span><span class="cov8" title="1">{
                v.calculateColumnWidths()
        }</span>

        // Render header
        <span class="cov8" title="1">var headerCells []string
        for i, header := range v.headers </span><span class="cov8" title="1">{
                width := 15 // default width
                if i &lt; len(v.columnWidths) </span><span class="cov8" title="1">{
                        width = v.columnWidths[i]
                }</span>
                <span class="cov8" title="1">cell := v.styleHeaderCell(header, width)
                headerCells = append(headerCells, cell)</span>
        }
        <span class="cov8" title="1">headerRow := strings.Join(headerCells, " ")

        // Style the header with border
        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("7")).
                BorderBottom(true).
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(lipgloss.Color("240")).
                Width(v.width)
        styledHeader := headerStyle.Render(headerRow)

        // Calculate viewport
        if v.viewportHeight == 0 </span><span class="cov0" title="0">{
                v.viewportHeight = v.height - 6 // Account for header and borders
        }</span>

        // Ensure selected row is within bounds
        <span class="cov8" title="1">if v.selectedRow &gt;= len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = len(v.rows) - 1
        }</span>
        <span class="cov8" title="1">if v.selectedRow &lt; 0 &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                v.selectedRow = 0
        }</span>

        // Ensure viewportStart is within bounds
        <span class="cov8" title="1">if v.viewportStart &gt;= len(v.rows) </span><span class="cov0" title="0">{
                v.viewportStart = 0
                if len(v.rows) &gt; v.viewportHeight </span><span class="cov0" title="0">{
                        v.viewportStart = len(v.rows) - v.viewportHeight
                }</span>
        }
        <span class="cov8" title="1">if v.viewportStart &lt; 0 </span><span class="cov0" title="0">{
                v.viewportStart = 0
        }</span>

        // Ensure selected row is visible
        <span class="cov8" title="1">if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span> else<span class="cov8" title="1"> if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span>

        // Render visible rows
        <span class="cov8" title="1">var renderedRows []string
        endRow := v.viewportStart + v.viewportHeight
        if endRow &gt; len(v.rows) </span><span class="cov8" title="1">{
                endRow = len(v.rows)
        }</span>

        <span class="cov8" title="1">for i := v.viewportStart; i &lt; endRow &amp;&amp; i &lt; len(v.rows); i++ </span><span class="cov8" title="1">{
                if i &lt; 0 || i &gt;= len(v.rows) </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid indices
                }
                <span class="cov8" title="1">row := v.rows[i]
                isSelected := i == v.selectedRow
                var cells []string

                for j, cell := range row </span><span class="cov8" title="1">{
                        if j &lt; len(v.headers) </span><span class="cov8" title="1">{
                                width := 15 // default width
                                if j &lt; len(v.columnWidths) </span><span class="cov8" title="1">{
                                        width = v.columnWidths[j]
                                }</span>
                                <span class="cov8" title="1">styledCell := v.styleCellByColumn(v.headers[j], cell, width, isSelected)
                                cells = append(cells, styledCell)</span>
                        }
                }

                <span class="cov8" title="1">rowStr := strings.Join(cells, " ")
                renderedRows = append(renderedRows, rowStr)</span>
        }

        // Join all rows
        <span class="cov8" title="1">tableContent := strings.Join(renderedRows, "\n")

        // Add scroll indicators if needed
        if v.viewportStart &gt; 0 || endRow &lt; len(v.rows) </span><span class="cov0" title="0">{
                scrollInfo := fmt.Sprintf(" [%d-%d of %d]", v.viewportStart+1, endRow, len(v.rows))
                scrollStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
                tableContent += "\n" + scrollStyle.Render(scrollInfo)
        }</span>

        // Combine header and content
        <span class="cov8" title="1">return lipgloss.JoinVertical(lipgloss.Left, styledHeader, tableContent)</span>
}

// styleHeaderCell styles a header cell
func (v *ResourceView) styleHeaderCell(header string, width int) string <span class="cov8" title="1">{
        style := lipgloss.NewStyle().Width(width).Bold(true)

        // Right-align numeric columns
        if header == "CPU" || header == "MEMORY" || header == "READY" ||
                header == "RESTARTS" || header == "DATA" || header == "UP-TO-DATE" ||
                header == "AVAILABLE" </span><span class="cov8" title="1">{
                style = style.Align(lipgloss.Right)
        }</span>

        <span class="cov8" title="1">return style.Render(header)</span>
}

// styleCellByColumn applies appropriate styling based on column type
func (v *ResourceView) styleCellByColumn(columnName, value string, width int, isSelected bool) string <span class="cov8" title="1">{
        // Handle word wrap
        displayValue := value
        actualWidth := width

        if v.wordWrap </span><span class="cov0" title="0">{
                // When wrap is ON, respect the column width and truncate if needed
                if len(value) &gt; width-2 &amp;&amp; width &gt; 5 </span><span class="cov0" title="0">{
                        displayValue = value[:width-5] + "..."
                }</span>
        } else<span class="cov8" title="1"> {
                // When wrap is OFF, don't truncate - show full content
                // Adjust width if content is longer
                if len(value) &gt; width </span><span class="cov0" title="0">{
                        actualWidth = len(value) + 2
                }</span>
        }

        <span class="cov8" title="1">switch columnName </span>{
        case "STATUS":<span class="cov8" title="1">
                return v.styleStatusCell(displayValue, actualWidth, isSelected)</span>
        case "CPU":<span class="cov0" title="0">
                return v.styleMetricCell(displayValue, actualWidth, isSelected, true)</span>
        case "MEMORY":<span class="cov0" title="0">
                return v.styleMetricCell(displayValue, actualWidth, isSelected, false)</span>
        case "RESTARTS":<span class="cov8" title="1">
                return v.styleRestartsCell(displayValue, actualWidth, isSelected)</span>
        case "READY", "UP-TO-DATE", "AVAILABLE", "DATA":<span class="cov8" title="1">
                // Right-align numeric columns
                style := lipgloss.NewStyle().Width(actualWidth).Align(lipgloss.Right)
                if isSelected </span><span class="cov8" title="1">{
                        style = style.Background(lipgloss.Color("57")).Foreground(lipgloss.Color("229"))
                }</span>
                <span class="cov8" title="1">return style.Render(displayValue)</span>
        default:<span class="cov8" title="1">
                // Default left-aligned
                style := lipgloss.NewStyle().Width(actualWidth)
                if isSelected </span><span class="cov8" title="1">{
                        style = style.Background(lipgloss.Color("57")).Foreground(lipgloss.Color("229"))
                }</span>
                <span class="cov8" title="1">return style.Render(displayValue)</span>
        }
}

// styleStatusCell applies color based on pod status
func (v *ResourceView) styleStatusCell(status string, width int, isSelected bool) string <span class="cov8" title="1">{
        style := lipgloss.NewStyle().Width(width)

        // Apply selection background
        if isSelected </span><span class="cov8" title="1">{
                style = style.Background(lipgloss.Color("57")).Foreground(lipgloss.Color("229"))
                return style.Render(status)
        }</span>

        // Apply status-based colors
        <span class="cov8" title="1">switch status </span>{
        case "Running":<span class="cov8" title="1">
                style = style.Foreground(lipgloss.Color("2"))</span> // Green
        case "Pending", "ContainerCreating":<span class="cov8" title="1">
                style = style.Foreground(lipgloss.Color("3"))</span> // Yellow
        case "Failed", "Error", "CrashLoopBackOff", "ImagePullBackOff":<span class="cov0" title="0">
                style = style.Foreground(lipgloss.Color("1"))</span> // Red
        case "Completed":<span class="cov0" title="0">
                style = style.Foreground(lipgloss.Color("4"))</span> // Blue
        case "Terminating":<span class="cov0" title="0">
                style = style.Foreground(lipgloss.Color("5"))</span> // Magenta
        default:<span class="cov0" title="0">
                style = style.Foreground(lipgloss.Color("7"))</span> // Default
        }

        <span class="cov8" title="1">return style.Render(status)</span>
}

// styleMetricCell applies color based on resource usage
func (v *ResourceView) styleMetricCell(value string, width int, isSelected bool, isCPU bool) string <span class="cov0" title="0">{
        style := lipgloss.NewStyle().Width(width).Align(lipgloss.Right)

        // Apply selection background
        if isSelected </span><span class="cov0" title="0">{
                style = style.Background(lipgloss.Color("57")).Foreground(lipgloss.Color("229"))
                return style.Render(value)
        }</span>

        // Skip if no value or "-"
        <span class="cov0" title="0">if value == "-" || value == "" </span><span class="cov0" title="0">{
                style = style.Foreground(lipgloss.Color("241")) // Gray for no data
                return style.Render(value)
        }</span>

        // Parse the numeric value
        <span class="cov0" title="0">var numValue float64
        if isCPU </span><span class="cov0" title="0">{
                // CPU values like "100m", "1", "2500m"
                if strings.HasSuffix(value, "m") </span><span class="cov0" title="0">{
                        // Millicores
                        numStr := strings.TrimSuffix(value, "m")
                        if val, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                                numValue = val / 1000.0 // Convert to cores
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Cores
                        if val, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                numValue = val
                        }</span>
                }

                // Color based on CPU usage (in cores)
                <span class="cov0" title="0">if numValue &lt; 0.1 </span><span class="cov0" title="0">{
                        style = style.Foreground(lipgloss.Color("2")) // Green for low
                }</span> else<span class="cov0" title="0"> if numValue &lt; 0.5 </span><span class="cov0" title="0">{
                        style = style.Foreground(lipgloss.Color("3")) // Yellow for medium
                }</span> else<span class="cov0" title="0"> {
                        style = style.Foreground(lipgloss.Color("1")) // Red for high
                }</span>
        } else<span class="cov0" title="0"> {
                // Memory values like "128Mi", "1Gi", "512Ki"
                var multiplier float64 = 1
                cleanValue := value

                if strings.HasSuffix(value, "Gi") </span><span class="cov0" title="0">{
                        multiplier = 1024
                        cleanValue = strings.TrimSuffix(value, "Gi")
                }</span> else<span class="cov0" title="0"> if strings.HasSuffix(value, "Mi") </span><span class="cov0" title="0">{
                        multiplier = 1
                        cleanValue = strings.TrimSuffix(value, "Mi")
                }</span> else<span class="cov0" title="0"> if strings.HasSuffix(value, "Ki") </span><span class="cov0" title="0">{
                        multiplier = 1.0 / 1024.0
                        cleanValue = strings.TrimSuffix(value, "Ki")
                }</span>

                <span class="cov0" title="0">if val, err := strconv.ParseFloat(cleanValue, 64); err == nil </span><span class="cov0" title="0">{
                        numValue = val * multiplier // Convert to Mi
                }</span>

                // Color based on memory usage (in Mi)
                <span class="cov0" title="0">if numValue &lt; 128 </span><span class="cov0" title="0">{
                        style = style.Foreground(lipgloss.Color("2")) // Green for low
                }</span> else<span class="cov0" title="0"> if numValue &lt; 512 </span><span class="cov0" title="0">{
                        style = style.Foreground(lipgloss.Color("3")) // Yellow for medium
                }</span> else<span class="cov0" title="0"> {
                        style = style.Foreground(lipgloss.Color("1")) // Red for high
                }</span>
        }

        <span class="cov0" title="0">return style.Render(value)</span>
}

// styleRestartsCell applies color based on restart count
func (v *ResourceView) styleRestartsCell(value string, width int, isSelected bool) string <span class="cov8" title="1">{
        style := lipgloss.NewStyle().Width(width).Align(lipgloss.Right)

        // Apply selection background
        if isSelected </span><span class="cov8" title="1">{
                style = style.Background(lipgloss.Color("57")).Foreground(lipgloss.Color("229"))
                return style.Render(value)
        }</span>

        // Extract number from format like "5 (2m ago)"
        <span class="cov8" title="1">numStr := strings.Split(value, " ")[0]
        restarts, err := strconv.Atoi(numStr)

        if err == nil </span><span class="cov8" title="1">{
                if restarts == 0 </span><span class="cov8" title="1">{
                        style = style.Foreground(lipgloss.Color("241")) // Gray for zero
                }</span> else<span class="cov8" title="1"> if restarts &lt; 5 </span><span class="cov8" title="1">{
                        style = style.Foreground(lipgloss.Color("3")) // Yellow for low
                }</span> else<span class="cov0" title="0"> {
                        style = style.Foreground(lipgloss.Color("1")) // Red for high
                }</span>
        }

        <span class="cov8" title="1">return style.Render(value)</span>
}

// restoreSelection intelligently restores the selection after updating rows
func (v *ResourceView) restoreSelection(newSelectedRow, previousSelectedRow int) <span class="cov0" title="0">{
        if newSelectedRow &gt;= 0 </span><span class="cov0" title="0">{
                // Found the same resource, select it
                v.selectedRow = newSelectedRow
        }</span> else<span class="cov0" title="0"> if previousSelectedRow &lt; len(v.rows) </span><span class="cov0" title="0">{
                // Keep the same position if possible
                v.selectedRow = previousSelectedRow
        }</span> else<span class="cov0" title="0"> if len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                // Select the last item if previous position is out of bounds
                v.selectedRow = len(v.rows) - 1
        }</span> else<span class="cov0" title="0"> {
                // No items left
                v.selectedRow = 0
                v.viewportStart = 0
                return
        }</span>

        // Ensure viewport is within bounds first
        <span class="cov0" title="0">if v.viewportStart &gt;= len(v.rows) </span><span class="cov0" title="0">{
                v.viewportStart = 0
                if len(v.rows) &gt; v.viewportHeight </span><span class="cov0" title="0">{
                        v.viewportStart = len(v.rows) - v.viewportHeight
                }</span>
        }
        <span class="cov0" title="0">if v.viewportStart &lt; 0 </span><span class="cov0" title="0">{
                v.viewportStart = 0
        }</span>

        // Adjust viewport to keep selection visible
        <span class="cov0" title="0">if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
                if v.viewportStart &lt; 0 </span><span class="cov0" title="0">{
                        v.viewportStart = 0
                }</span>
        } else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>
}

// calculateColumnWidths calculates the width for each column based on content
func (v *ResourceView) calculateColumnWidths() <span class="cov8" title="1">{
        if len(v.headers) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Initialize with header widths
        <span class="cov8" title="1">v.columnWidths = make([]int, len(v.headers))
        for i, header := range v.headers </span><span class="cov8" title="1">{
                v.columnWidths[i] = len(header) + 2
        }</span>

        // Check all rows for max width
        <span class="cov8" title="1">for _, row := range v.rows </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        if i &lt; len(v.columnWidths) </span><span class="cov8" title="1">{
                                cellLen := len(cell) + 2
                                if cellLen &gt; v.columnWidths[i] </span><span class="cov8" title="1">{
                                        v.columnWidths[i] = cellLen
                                }</span>
                        }
                }
        }

        // Apply limits based on word wrap setting
        <span class="cov8" title="1">for i := range v.columnWidths </span><span class="cov8" title="1">{
                if v.columnWidths[i] &lt; 7 </span><span class="cov8" title="1">{
                        v.columnWidths[i] = 7
                }</span>
                // If word wrap is enabled, limit column width to prevent overly wide columns
                <span class="cov8" title="1">if v.wordWrap &amp;&amp; v.columnWidths[i] &gt; 50 </span><span class="cov0" title="0">{
                        v.columnWidths[i] = 50
                }</span>
                // When word wrap is off, no maximum limit - show full content
        }
}

func (v *ResourceView) renderHeader() string <span class="cov8" title="1">{
        title := fmt.Sprintf("KubeWatch TUI - %s", v.state.CurrentResourceType)
        namespace := fmt.Sprintf("Namespace: %s", v.state.CurrentNamespace)
        count := fmt.Sprintf("Count: %d", v.state.GetCurrentResourceCount())

        // Add context information
        var contextInfo string
        if v.isMultiContext &amp;&amp; len(v.state.CurrentContexts) &gt; 0 </span><span class="cov8" title="1">{
                contexts := strings.Join(v.state.CurrentContexts, ", ")
                if len(contexts) &gt; 30 </span><span class="cov0" title="0">{
                        contextInfo = fmt.Sprintf("Contexts: %d active", len(v.state.CurrentContexts))
                }</span> else<span class="cov8" title="1"> {
                        contextInfo = fmt.Sprintf("Contexts: %s", contexts)
                }</span>
        } else<span class="cov8" title="1"> if v.state.CurrentContext != "" </span><span class="cov8" title="1">{
                contextInfo = fmt.Sprintf("Context: %s", v.state.CurrentContext)
        }</span> else<span class="cov0" title="0"> {
                contextInfo = "Context: default"
        }</span>

        // Add word wrap indicator
        <span class="cov8" title="1">wrapStatus := "Wrap: OFF"
        if v.wordWrap </span><span class="cov0" title="0">{
                wrapStatus = "Wrap: ON"
        }</span>

        // Add sort indicator
        <span class="cov8" title="1">sortDirection := "↑"
        if !v.state.SortAscending </span><span class="cov8" title="1">{
                sortDirection = "↓"
        }</span>
        <span class="cov8" title="1">sortStatus := fmt.Sprintf("Sort: %s %s", v.state.SortColumn, sortDirection)

        // Add last refresh time
        refreshStatus := "Never"
        if !v.lastRefresh.IsZero() </span><span class="cov0" title="0">{
                elapsed := time.Since(v.lastRefresh)
                if elapsed &lt; time.Minute </span><span class="cov0" title="0">{
                        refreshStatus = fmt.Sprintf("%ds ago", int(elapsed.Seconds()))
                }</span> else<span class="cov0" title="0"> {
                        refreshStatus = fmt.Sprintf("%dm ago", int(elapsed.Minutes()))
                }</span>
        }

        <span class="cov8" title="1">titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("86"))
        infoStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        contextStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("5")) // Magenta for context
        wrapStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("3"))    // Yellow for wrap status
        sortStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("4"))    // Blue for sort status
        refreshStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("2")) // Green for refresh

        header := lipgloss.JoinHorizontal(
                lipgloss.Top,
                titleStyle.Render(title),
                strings.Repeat(" ", 10),
                contextStyle.Render(contextInfo),
                strings.Repeat(" ", 5),
                infoStyle.Render(namespace),
                strings.Repeat(" ", 5),
                infoStyle.Render(count),
                strings.Repeat(" ", 5),
                sortStyle.Render(sortStatus),
                strings.Repeat(" ", 5),
                wrapStyle.Render(wrapStatus),
                strings.Repeat(" ", 5),
                refreshStyle.Render("↻ "+refreshStatus),
        )

        return header + "\n"</span>
}

// updateColumnsForResourceType sets the appropriate columns for the current resource type
func (v *ResourceView) updateColumnsForResourceType() <span class="cov8" title="1">{
        // Check if we're viewing all namespaces or a specific one
        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Start with context column if in multi-context mode
        var baseHeaders []string
        if v.isMultiContext &amp;&amp; v.showContextColumn </span><span class="cov8" title="1">{
                baseHeaders = []string{"CONTEXT", "NAME"}
        }</span> else<span class="cov8" title="1"> {
                baseHeaders = []string{"NAME"}
        }</span>

        <span class="cov8" title="1">switch v.state.CurrentResourceType </span>{
        case core.ResourceTypePod:<span class="cov8" title="1">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov8" title="1">v.headers = append(v.headers, "READY", "STATUS", "RESTARTS", "AGE", "CPU", "MEMORY", "IP", "NODE")</span>

        case core.ResourceTypeDeployment:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "READY", "UP-TO-DATE", "AVAILABLE", "AGE", "CONTAINERS", "IMAGES", "SELECTOR")</span>

        case core.ResourceTypeStatefulSet:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "READY", "AGE", "CONTAINERS", "IMAGES")</span>

        case core.ResourceTypeService:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "TYPE", "CLUSTER-IP", "EXTERNAL-IP", "PORT(S)", "AGE")</span>

        case core.ResourceTypeIngress:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "CLASS", "HOSTS", "ADDRESS", "PORTS", "AGE")</span>

        case core.ResourceTypeConfigMap:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "DATA", "AGE")</span>

        case core.ResourceTypeSecret:<span class="cov0" title="0">
                v.headers = baseHeaders
                if showNamespace </span><span class="cov0" title="0">{
                        v.headers = append(v.headers, "NAMESPACE")
                }</span>
                <span class="cov0" title="0">v.headers = append(v.headers, "TYPE", "DATA", "AGE")</span>
        }
}

func (v *ResourceView) updateTableWithPods(pods []v1.Pod) <span class="cov0" title="0">{
        // Update columns for pods
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Save the currently selected resource identity
        v.saveSelectedIdentity()

        // Preserve the currently selected resource name and position (for fallback)
        var selectedResourceName string
        previousSelectedRow := v.selectedRow
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows and resource map
        <span class="cov0" title="0">v.rows = [][]string{}
        v.resourceMap = make(map[int]*ResourceIdentity)
        newSelectedRow := -1 // Will update this if we find the previously selected resource

        for _, pod := range pods </span><span class="cov0" title="0">{
                // Calculate ready containers
                readyContainers := 0
                totalContainers := len(pod.Status.ContainerStatuses)
                restartCount := int32(0)
                var lastRestartTime *time.Time

                for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                        if cs.Ready </span><span class="cov0" title="0">{
                                readyContainers++
                        }</span>
                        <span class="cov0" title="0">restartCount += cs.RestartCount
                        if cs.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                t := cs.LastTerminationState.Terminated.FinishedAt.Time
                                if lastRestartTime == nil || t.After(*lastRestartTime) </span><span class="cov0" title="0">{
                                        lastRestartTime = &amp;t
                                }</span>
                        }
                }

                <span class="cov0" title="0">ready := fmt.Sprintf("%d/%d", readyContainers, totalContainers)
                status := string(pod.Status.Phase)

                // Get more detailed status if available
                for _, condition := range pod.Status.Conditions </span><span class="cov0" title="0">{
                        if condition.Type == v1.PodReady &amp;&amp; condition.Status != v1.ConditionTrue </span><span class="cov0" title="0">{
                                if condition.Reason != "" </span><span class="cov0" title="0">{
                                        status = condition.Reason
                                }</span>
                        }
                }

                // Check container statuses for more specific states
                <span class="cov0" title="0">for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                        if cs.State.Waiting != nil &amp;&amp; cs.State.Waiting.Reason != "" </span><span class="cov0" title="0">{
                                status = cs.State.Waiting.Reason
                                break</span>
                        }
                        <span class="cov0" title="0">if cs.State.Terminated != nil &amp;&amp; cs.State.Terminated.Reason != "" </span><span class="cov0" title="0">{
                                status = cs.State.Terminated.Reason
                                break</span>
                        }
                }

                // Format restart count with time if available
                <span class="cov0" title="0">restartStr := fmt.Sprintf("%d", restartCount)
                if restartCount &gt; 0 &amp;&amp; lastRestartTime != nil </span><span class="cov0" title="0">{
                        restartAge := getAge(*lastRestartTime)
                        restartStr = fmt.Sprintf("%d (%s ago)", restartCount, restartAge)
                }</span>

                <span class="cov0" title="0">age := getAge(pod.CreationTimestamp.Time)

                // Get metrics if available
                cpu := "-"
                memory := "-"
                if v.podMetrics != nil </span><span class="cov0" title="0">{
                        if metrics, ok := v.podMetrics[pod.Name]; ok </span><span class="cov0" title="0">{
                                cpu = metrics.CPU
                                memory = metrics.Memory
                        }</span>
                }

                // Get IP and Node
                <span class="cov0" title="0">ip := pod.Status.PodIP
                if ip == "" </span><span class="cov0" title="0">{
                        ip = "-"
                }</span>
                <span class="cov0" title="0">node := pod.Spec.NodeName
                if node == "" </span><span class="cov0" title="0">{
                        node = "-"
                }</span>

                // Build row data
                <span class="cov0" title="0">rowData := []string{pod.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, pod.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, ready, status, restartStr, age, cpu, memory, ip, node)
                v.rows = append(v.rows, rowData)

                // Create resource identity for this row
                rowIndex := len(v.rows) - 1
                identity := &amp;ResourceIdentity{
                        Context:   "", // Single context mode
                        Namespace: pod.Namespace,
                        Name:      pod.Name,
                        UID:       string(pod.UID),
                        Kind:      "Pod",
                }
                v.resourceMap[rowIndex] = identity

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; pod.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection intelligently
        // Try to restore selection by identity first, then fall back to old method
        <span class="cov0" title="0">v.restoreSelectionByIdentity()

        // If identity-based restoration didn't work, use the old method as fallback
        if v.selectedIdentity != nil &amp;&amp; v.findResourceByIdentity(v.selectedIdentity) &lt; 0 </span><span class="cov0" title="0">{
                v.restoreSelection(newSelectedRow, previousSelectedRow)
        }</span>

        // Adjust viewport to keep selection visible
        <span class="cov0" title="0">if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Sort the rows
        v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithDeployments(deployments []appsv1.Deployment) <span class="cov0" title="0">{
        // Update columns for deployments
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := 0 // Will update this if we find the previously selected resource

        for _, dep := range deployments </span><span class="cov0" title="0">{
                replicas := int32(0)
                if dep.Spec.Replicas != nil </span><span class="cov0" title="0">{
                        replicas = *dep.Spec.Replicas
                }</span>
                <span class="cov0" title="0">ready := fmt.Sprintf("%d/%d", dep.Status.ReadyReplicas, replicas)
                upToDate := fmt.Sprintf("%d", dep.Status.UpdatedReplicas)
                available := fmt.Sprintf("%d", dep.Status.AvailableReplicas)
                age := getAge(dep.CreationTimestamp.Time)

                // Get containers and images
                var containers []string
                var images []string
                for _, container := range dep.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                        containers = append(containers, container.Name)
                        images = append(images, container.Image)
                }</span>
                <span class="cov0" title="0">containersStr := strings.Join(containers, ",")
                imagesStr := strings.Join(images, ",")

                // Get selector
                var selectors []string
                for k, v := range dep.Spec.Selector.MatchLabels </span><span class="cov0" title="0">{
                        selectors = append(selectors, fmt.Sprintf("%s=%s", k, v))
                }</span>
                <span class="cov0" title="0">selectorStr := strings.Join(selectors, ",")

                // Build row data
                rowData := []string{dep.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, dep.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, ready, upToDate, available, age, containersStr, imagesStr, selectorStr)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; dep.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection
        <span class="cov0" title="0">v.selectedRow = newSelectedRow

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithStatefulSets(statefulsets []appsv1.StatefulSet) <span class="cov0" title="0">{
        // Update columns for statefulsets
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := 0 // Will update this if we find the previously selected resource

        for _, sts := range statefulsets </span><span class="cov0" title="0">{
                replicas := int32(0)
                if sts.Spec.Replicas != nil </span><span class="cov0" title="0">{
                        replicas = *sts.Spec.Replicas
                }</span>
                <span class="cov0" title="0">ready := fmt.Sprintf("%d/%d", sts.Status.ReadyReplicas, replicas)
                age := getAge(sts.CreationTimestamp.Time)

                // Get containers and images
                var containers []string
                var images []string
                for _, container := range sts.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                        containers = append(containers, container.Name)
                        images = append(images, container.Image)
                }</span>
                <span class="cov0" title="0">containersStr := strings.Join(containers, ",")
                imagesStr := strings.Join(images, ",")

                // Build row data
                rowData := []string{sts.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, sts.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, ready, age, containersStr, imagesStr)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; sts.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection
        <span class="cov0" title="0">v.selectedRow = newSelectedRow

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithServices(services []v1.Service) <span class="cov0" title="0">{
        // Update columns for services
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := 0 // Will update this if we find the previously selected resource

        for _, svc := range services </span><span class="cov0" title="0">{
                svcType := string(svc.Spec.Type)
                clusterIP := svc.Spec.ClusterIP
                if clusterIP == "" </span><span class="cov0" title="0">{
                        clusterIP = "None"
                }</span>

                // Get external IPs
                <span class="cov0" title="0">externalIP := "&lt;none&gt;"
                if len(svc.Spec.ExternalIPs) &gt; 0 </span><span class="cov0" title="0">{
                        externalIP = strings.Join(svc.Spec.ExternalIPs, ",")
                }</span> else<span class="cov0" title="0"> if svc.Spec.Type == v1.ServiceTypeLoadBalancer &amp;&amp; len(svc.Status.LoadBalancer.Ingress) &gt; 0 </span><span class="cov0" title="0">{
                        var ips []string
                        for _, ingress := range svc.Status.LoadBalancer.Ingress </span><span class="cov0" title="0">{
                                if ingress.IP != "" </span><span class="cov0" title="0">{
                                        ips = append(ips, ingress.IP)
                                }</span> else<span class="cov0" title="0"> if ingress.Hostname != "" </span><span class="cov0" title="0">{
                                        ips = append(ips, ingress.Hostname)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                                externalIP = strings.Join(ips, ",")
                        }</span>
                }

                // Get ports
                <span class="cov0" title="0">var ports []string
                for _, port := range svc.Spec.Ports </span><span class="cov0" title="0">{
                        portStr := fmt.Sprintf("%d", port.Port)
                        if port.NodePort != 0 </span><span class="cov0" title="0">{
                                portStr = fmt.Sprintf("%d:%d", port.Port, port.NodePort)
                        }</span>
                        <span class="cov0" title="0">if port.Protocol != "" &amp;&amp; port.Protocol != "TCP" </span><span class="cov0" title="0">{
                                portStr = fmt.Sprintf("%s/%s", portStr, port.Protocol)
                        }</span>
                        <span class="cov0" title="0">if port.Name != "" </span><span class="cov0" title="0">{
                                portStr = fmt.Sprintf("%s(%s)", portStr, port.Name)
                        }</span>
                        <span class="cov0" title="0">ports = append(ports, portStr)</span>
                }
                <span class="cov0" title="0">portStr := "&lt;none&gt;"
                if len(ports) &gt; 0 </span><span class="cov0" title="0">{
                        portStr = strings.Join(ports, ",")
                        // Don't truncate - show full port information
                }</span>

                <span class="cov0" title="0">age := getAge(svc.CreationTimestamp.Time)

                // Build row data
                rowData := []string{svc.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, svc.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, svcType, clusterIP, externalIP, portStr, age)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; svc.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection
        <span class="cov0" title="0">v.selectedRow = newSelectedRow

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithIngresses(ingresses []networkingv1.Ingress) <span class="cov0" title="0">{
        // Update columns for ingresses
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        previousSelectedRow := v.selectedRow
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := -1 // Will update this if we find the previously selected resource

        for _, ing := range ingresses </span><span class="cov0" title="0">{
                // Get ingress class
                className := "&lt;none&gt;"
                if ing.Spec.IngressClassName != nil </span><span class="cov0" title="0">{
                        className = *ing.Spec.IngressClassName
                }</span>

                // Get hosts
                <span class="cov0" title="0">var hosts []string
                for _, rule := range ing.Spec.Rules </span><span class="cov0" title="0">{
                        if rule.Host != "" </span><span class="cov0" title="0">{
                                hosts = append(hosts, rule.Host)
                        }</span>
                }
                <span class="cov0" title="0">hostsStr := "&lt;none&gt;"
                if len(hosts) &gt; 0 </span><span class="cov0" title="0">{
                        hostsStr = strings.Join(hosts, ",")
                }</span>

                // Get addresses
                <span class="cov0" title="0">var addresses []string
                for _, ingStatus := range ing.Status.LoadBalancer.Ingress </span><span class="cov0" title="0">{
                        if ingStatus.IP != "" </span><span class="cov0" title="0">{
                                addresses = append(addresses, ingStatus.IP)
                        }</span> else<span class="cov0" title="0"> if ingStatus.Hostname != "" </span><span class="cov0" title="0">{
                                addresses = append(addresses, ingStatus.Hostname)
                        }</span>
                }
                <span class="cov0" title="0">addressStr := "&lt;none&gt;"
                if len(addresses) &gt; 0 </span><span class="cov0" title="0">{
                        addressStr = strings.Join(addresses, ",")
                }</span>

                // Get ports
                <span class="cov0" title="0">ports := "80"
                if len(ing.Spec.TLS) &gt; 0 </span><span class="cov0" title="0">{
                        ports = "80, 443"
                }</span>

                <span class="cov0" title="0">age := getAge(ing.CreationTimestamp.Time)

                // Build row data
                rowData := []string{ing.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, ing.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, className, hostsStr, addressStr, ports, age)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; ing.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection intelligently
        <span class="cov0" title="0">v.restoreSelection(newSelectedRow, previousSelectedRow)

        // Sort the rows
        v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithConfigMaps(configmaps []v1.ConfigMap) <span class="cov0" title="0">{
        // Update columns for configmaps
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := 0 // Will update this if we find the previously selected resource

        for _, cm := range configmaps </span><span class="cov0" title="0">{
                dataCount := fmt.Sprintf("%d", len(cm.Data)+len(cm.BinaryData))
                age := getAge(cm.CreationTimestamp.Time)

                // Build row data
                rowData := []string{cm.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, cm.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, dataCount, age)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; cm.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection
        <span class="cov0" title="0">v.selectedRow = newSelectedRow

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithSecrets(secrets []v1.Secret) <span class="cov0" title="0">{
        // Update columns for secrets
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := 0 // Will update this if we find the previously selected resource

        for _, secret := range secrets </span><span class="cov0" title="0">{
                secretType := string(secret.Type)
                dataCount := fmt.Sprintf("%d", len(secret.Data))
                age := getAge(secret.CreationTimestamp.Time)

                // Build row data
                rowData := []string{secret.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, secret.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, secretType, dataCount, age)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; secret.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection
        <span class="cov0" title="0">v.selectedRow = newSelectedRow

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

// sortRows sorts the table rows based on the current sort configuration
func (v *ResourceView) sortRows() <span class="cov0" title="0">{
        if len(v.rows) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Determine which column to sort by
        <span class="cov0" title="0">sortColumn := v.state.SortColumn
        if sortColumn == "" </span><span class="cov0" title="0">{
                sortColumn = "NAME" // Default sort by name
        }</span>

        // Find the column index
        <span class="cov0" title="0">sortColumnIndex := -1
        for i, header := range v.headers </span><span class="cov0" title="0">{
                if header == sortColumn </span><span class="cov0" title="0">{
                        sortColumnIndex = i
                        break</span>
                }
        }

        // If column not found, sort by first column (NAME)
        <span class="cov0" title="0">if sortColumnIndex == -1 </span><span class="cov0" title="0">{
                sortColumnIndex = 0
        }</span>

        // Sort the rows
        <span class="cov0" title="0">sort.Slice(v.rows, func(i, j int) bool </span><span class="cov0" title="0">{
                if sortColumnIndex &gt;= len(v.rows[i]) || sortColumnIndex &gt;= len(v.rows[j]) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">valueI := v.rows[i][sortColumnIndex]
                valueJ := v.rows[j][sortColumnIndex]

                // Handle numeric columns specially
                if sortColumn == "READY" || sortColumn == "RESTARTS" || sortColumn == "AGE" </span><span class="cov0" title="0">{
                        return v.compareNumericValues(valueI, valueJ, v.state.SortAscending)
                }</span>

                // String comparison
                <span class="cov0" title="0">if v.state.SortAscending </span><span class="cov0" title="0">{
                        return strings.ToLower(valueI) &lt; strings.ToLower(valueJ)
                }</span>
                <span class="cov0" title="0">return strings.ToLower(valueI) &gt; strings.ToLower(valueJ)</span>
        })
}

// compareNumericValues compares two values that might be numeric
func (v *ResourceView) compareNumericValues(valueI, valueJ string, ascending bool) bool <span class="cov0" title="0">{
        // Try to extract numeric values for comparison
        numI := v.extractNumericValue(valueI)
        numJ := v.extractNumericValue(valueJ)

        if ascending </span><span class="cov0" title="0">{
                return numI &lt; numJ
        }</span>
        <span class="cov0" title="0">return numI &gt; numJ</span>
}

// extractNumericValue extracts a numeric value from a string for sorting
func (v *ResourceView) extractNumericValue(value string) float64 <span class="cov0" title="0">{
        // Handle ready format "1/2"
        if strings.Contains(value, "/") </span><span class="cov0" title="0">{
                parts := strings.Split(value, "/")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        ready, err1 := strconv.ParseFloat(parts[0], 64)
                        total, err2 := strconv.ParseFloat(parts[1], 64)
                        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; total &gt; 0 </span><span class="cov0" title="0">{
                                return ready / total // Return percentage
                        }</span>
                }
        }

        // Handle restart count with time "5 (2m ago)"
        <span class="cov0" title="0">if strings.Contains(value, " (") </span><span class="cov0" title="0">{
                parts := strings.Split(value, " (")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        if num, err := strconv.ParseFloat(parts[0], 64); err == nil </span><span class="cov0" title="0">{
                                return num
                        }</span>
                }
        }

        // Handle age format
        <span class="cov0" title="0">if strings.HasSuffix(value, "s") || strings.HasSuffix(value, "m") ||
                strings.HasSuffix(value, "h") || strings.HasSuffix(value, "d") ||
                strings.HasSuffix(value, "mo") || strings.HasSuffix(value, "y") </span><span class="cov0" title="0">{
                return v.parseAgeToSeconds(value)
        }</span>

        // Try direct numeric conversion
        <span class="cov0" title="0">if num, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return num
        }</span>

        // Default to 0 for non-numeric values
        <span class="cov0" title="0">return 0</span>
}

// parseAgeToSeconds converts age string to seconds for sorting
func (v *ResourceView) parseAgeToSeconds(age string) float64 <span class="cov0" title="0">{
        if len(age) &lt; 2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">valueStr := age[:len(age)-1]
        unit := age[len(age)-1:]

        // Handle "mo" and "y" units
        if len(age) &gt;= 3 &amp;&amp; age[len(age)-2:] == "mo" </span><span class="cov0" title="0">{
                valueStr = age[:len(age)-2]
                unit = "mo"
        }</span> else<span class="cov0" title="0"> if len(age) &gt;= 2 &amp;&amp; age[len(age)-1:] == "y" </span><span class="cov0" title="0">{
                unit = "y"
        }</span>

        <span class="cov0" title="0">value, err := strconv.ParseFloat(valueStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">switch unit </span>{
        case "s":<span class="cov0" title="0">
                return value</span>
        case "m":<span class="cov0" title="0">
                return value * 60</span>
        case "h":<span class="cov0" title="0">
                return value * 3600</span>
        case "d":<span class="cov0" title="0">
                return value * 86400</span>
        case "mo":<span class="cov0" title="0">
                return value * 2592000</span> // 30 days
        case "y":<span class="cov0" title="0">
                return value * 31536000</span> // 365 days
        default:<span class="cov0" title="0">
                return value</span>
        }
}

// Multi-context table update methods

func (v *ResourceView) updateTableWithPodsMultiContext(podsWithContext []k8s.PodWithContext) <span class="cov0" title="0">{
        // Update columns for pods with context column
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Save the currently selected resource identity
        v.saveSelectedIdentity()

        // Preserve the currently selected resource name and position (for fallback)
        var selectedResourceName string
        previousSelectedRow := v.selectedRow
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                // In multi-context mode, first column is CONTEXT, second is NAME
                if len(v.rows[v.selectedRow]) &gt; 1 </span><span class="cov0" title="0">{
                        selectedResourceName = v.rows[v.selectedRow][1]
                }</span>
        }

        // Clear and rebuild rows and resource map
        <span class="cov0" title="0">v.rows = [][]string{}
        v.resourceMap = make(map[int]*ResourceIdentity)
        newSelectedRow := -1

        for _, pwc := range podsWithContext </span><span class="cov0" title="0">{
                pod := pwc.Pod
                context := pwc.Context

                // Calculate ready containers
                readyContainers := 0
                totalContainers := len(pod.Status.ContainerStatuses)
                restartCount := int32(0)
                var lastRestartTime *time.Time

                for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                        if cs.Ready </span><span class="cov0" title="0">{
                                readyContainers++
                        }</span>
                        <span class="cov0" title="0">restartCount += cs.RestartCount
                        if cs.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                t := cs.LastTerminationState.Terminated.FinishedAt.Time
                                if lastRestartTime == nil || t.After(*lastRestartTime) </span><span class="cov0" title="0">{
                                        lastRestartTime = &amp;t
                                }</span>
                        }
                }

                <span class="cov0" title="0">ready := fmt.Sprintf("%d/%d", readyContainers, totalContainers)
                status := string(pod.Status.Phase)

                // Get more detailed status if available
                for _, condition := range pod.Status.Conditions </span><span class="cov0" title="0">{
                        if condition.Type == v1.PodReady &amp;&amp; condition.Status != v1.ConditionTrue </span><span class="cov0" title="0">{
                                if condition.Reason != "" </span><span class="cov0" title="0">{
                                        status = condition.Reason
                                }</span>
                        }
                }

                // Check container statuses for more specific states
                <span class="cov0" title="0">for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                        if cs.State.Waiting != nil &amp;&amp; cs.State.Waiting.Reason != "" </span><span class="cov0" title="0">{
                                status = cs.State.Waiting.Reason
                                break</span>
                        }
                        <span class="cov0" title="0">if cs.State.Terminated != nil &amp;&amp; cs.State.Terminated.Reason != "" </span><span class="cov0" title="0">{
                                status = cs.State.Terminated.Reason
                                break</span>
                        }
                }

                // Format restart count with time if available
                <span class="cov0" title="0">restartStr := fmt.Sprintf("%d", restartCount)
                if restartCount &gt; 0 &amp;&amp; lastRestartTime != nil </span><span class="cov0" title="0">{
                        restartAge := getAge(*lastRestartTime)
                        restartStr = fmt.Sprintf("%d (%s ago)", restartCount, restartAge)
                }</span>

                <span class="cov0" title="0">age := getAge(pod.CreationTimestamp.Time)

                // Get metrics if available
                cpu := "-"
                memory := "-"
                if v.podMetrics != nil </span><span class="cov0" title="0">{
                        if metrics, ok := v.podMetrics[pod.Name]; ok </span><span class="cov0" title="0">{
                                cpu = metrics.CPU
                                memory = metrics.Memory
                        }</span>
                }

                // Get IP and Node
                <span class="cov0" title="0">ip := pod.Status.PodIP
                if ip == "" </span><span class="cov0" title="0">{
                        ip = "-"
                }</span>
                <span class="cov0" title="0">node := pod.Spec.NodeName
                if node == "" </span><span class="cov0" title="0">{
                        node = "-"
                }</span>

                // Build row data with context column first
                <span class="cov0" title="0">rowData := []string{context, pod.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, pod.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, ready, status, restartStr, age, cpu, memory, ip, node)
                v.rows = append(v.rows, rowData)

                // Create resource identity for this row
                rowIndex := len(v.rows) - 1
                identity := &amp;ResourceIdentity{
                        Context:   context,
                        Namespace: pod.Namespace,
                        Name:      pod.Name,
                        UID:       string(pod.UID),
                        Kind:      "Pod",
                }
                v.resourceMap[rowIndex] = identity

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; pod.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Try to restore selection by identity first, then fall back to old method
        <span class="cov0" title="0">v.restoreSelectionByIdentity()

        // If identity-based restoration didn't work, use the old method as fallback
        if v.selectedIdentity != nil &amp;&amp; v.findResourceByIdentity(v.selectedIdentity) &lt; 0 </span><span class="cov0" title="0">{
                v.restoreSelection(newSelectedRow, previousSelectedRow)
        }</span>
        <span class="cov0" title="0">v.restoreSelection(newSelectedRow, previousSelectedRow)

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

func (v *ResourceView) updateTableWithDeploymentsMultiContext(deploymentsWithContext []k8s.DeploymentWithContext) <span class="cov0" title="0">{
        // Update columns for deployments with context column
        v.updateColumnsForResourceType()

        showNamespace := v.state.CurrentNamespace == "" || v.state.CurrentNamespace == "all"

        // Preserve the currently selected resource name
        var selectedResourceName string
        previousSelectedRow := v.selectedRow
        if v.selectedRow &gt;= 0 &amp;&amp; v.selectedRow &lt; len(v.rows) &amp;&amp; len(v.rows) &gt; 0 </span><span class="cov0" title="0">{
                selectedResourceName = v.rows[v.selectedRow][0] // First column is always NAME
        }</span>

        // Clear and rebuild rows
        <span class="cov0" title="0">v.rows = [][]string{}
        newSelectedRow := -1

        for _, dwc := range deploymentsWithContext </span><span class="cov0" title="0">{
                deployment := dwc.Deployment
                context := dwc.Context

                ready := fmt.Sprintf("%d/%d", deployment.Status.ReadyReplicas, deployment.Status.Replicas)
                upToDate := fmt.Sprintf("%d", deployment.Status.UpdatedReplicas)
                available := fmt.Sprintf("%d", deployment.Status.AvailableReplicas)
                age := getAge(deployment.CreationTimestamp.Time)

                // Build row data with context column first
                rowData := []string{context, deployment.Name}
                if showNamespace </span><span class="cov0" title="0">{
                        rowData = append(rowData, deployment.Namespace)
                }</span>
                <span class="cov0" title="0">rowData = append(rowData, ready, upToDate, available, age)
                v.rows = append(v.rows, rowData)

                // Check if this was the previously selected resource
                if selectedResourceName != "" &amp;&amp; deployment.Name == selectedResourceName </span><span class="cov0" title="0">{
                        newSelectedRow = len(v.rows) - 1
                }</span>
        }

        // Restore selection intelligently
        <span class="cov0" title="0">v.restoreSelection(newSelectedRow, previousSelectedRow)

        // Adjust viewport to keep selection visible
        if v.selectedRow &gt;= v.viewportStart+v.viewportHeight </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow - v.viewportHeight + 1
        }</span> else<span class="cov0" title="0"> if v.selectedRow &lt; v.viewportStart </span><span class="cov0" title="0">{
                v.viewportStart = v.selectedRow
        }</span>

        // Sort the rows
        <span class="cov0" title="0">v.sortRows()

        // Calculate column widths
        v.calculateColumnWidths()</span>
}

// Helper functions

func getAge(t time.Time) string <span class="cov0" title="0">{
        duration := time.Since(t)
        if duration.Hours() &gt; 24*365 </span><span class="cov0" title="0">{
                years := int(duration.Hours() / (24 * 365))
                return fmt.Sprintf("%dy", years)
        }</span> else<span class="cov0" title="0"> if duration.Hours() &gt; 24*30 </span><span class="cov0" title="0">{
                months := int(duration.Hours() / (24 * 30))
                return fmt.Sprintf("%dmo", months)
        }</span> else<span class="cov0" title="0"> if duration.Hours() &gt; 24 </span><span class="cov0" title="0">{
                days := int(duration.Hours() / 24)
                return fmt.Sprintf("%dd", days)
        }</span> else<span class="cov0" title="0"> if duration.Hours() &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", int(duration.Hours()))
        }</span> else<span class="cov0" title="0"> if duration.Minutes() &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", int(duration.Minutes()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%ds", int(duration.Seconds()))</span>
}

// Message types
type refreshCompleteMsg struct{}
type deleteCompleteMsg struct{ name string }
type errMsg struct{ err error }
</pre>
		
		<pre class="file" id="file11" style="display: none">package views

// Helper function for text matching in tests
func containsText(haystack, needle string) bool <span class="cov8" title="1">{
        if len(needle) &gt; len(haystack) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= len(haystack)-len(needle); i++ </span><span class="cov8" title="1">{
                if haystack[i:i+len(needle)] == needle </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
